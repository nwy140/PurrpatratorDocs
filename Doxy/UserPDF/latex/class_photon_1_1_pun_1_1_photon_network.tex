\doxysection{Photon.\+Pun.\+Photon\+Network Class Reference}
\label{class_photon_1_1_pun_1_1_photon_network}\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}


The main class to use the \doxyref{Photon\+Network}{p.}{class_photon_1_1_pun_1_1_photon_network} plugin.  




Collaboration diagram for Photon.\+Pun.\+Photon\+Network\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \textbf{ Connect\+Using\+Settings} ()
\begin{DoxyCompactList}\small\item\em Connect to \doxyref{Photon}{p.}{namespace_photon} as configured in the Photon\+Server\+Settings file. \end{DoxyCompactList}\item 
static bool \textbf{ Connect\+Using\+Settings} (\textbf{ App\+Settings} app\+Settings, bool start\+In\+Offline\+Mode=false)
\item 
static bool \textbf{ Connect\+To\+Master} (string master\+Server\+Address, int port, string app\+ID)
\begin{DoxyCompactList}\small\item\em Connect to a \doxyref{Photon}{p.}{namespace_photon} Master Server by address, port, app\+ID. \end{DoxyCompactList}\item 
static bool \textbf{ Connect\+To\+Best\+Cloud\+Server} ()
\begin{DoxyCompactList}\small\item\em Connect to the \doxyref{Photon}{p.}{namespace_photon} Cloud region with the lowest ping (on platforms that support Unity\textquotesingle{}s Ping). \end{DoxyCompactList}\item 
static bool \textbf{ Connect\+To\+Region} (string region)
\begin{DoxyCompactList}\small\item\em Connects to the \doxyref{Photon}{p.}{namespace_photon} Cloud region of choice. \end{DoxyCompactList}\item 
static void \textbf{ Disconnect} ()
\begin{DoxyCompactList}\small\item\em Makes this client disconnect from the photon server, a process that leaves any room and calls On\+Disconnected on completion. \end{DoxyCompactList}\item 
static bool \textbf{ Reconnect} ()
\begin{DoxyCompactList}\small\item\em Can be used to reconnect to the master server after a disconnect. \end{DoxyCompactList}\item 
static void \textbf{ Network\+Statistics\+Reset} ()
\begin{DoxyCompactList}\small\item\em Resets the traffic stats and re-\/enables them. \end{DoxyCompactList}\item 
static string \textbf{ Network\+Statistics\+To\+String} ()
\begin{DoxyCompactList}\small\item\em Only available when Network\+Statistics\+Enabled was used to gather some stats. \end{DoxyCompactList}\item 
static int \textbf{ Get\+Ping} ()
\begin{DoxyCompactList}\small\item\em The current roundtrip time to the photon server. \end{DoxyCompactList}\item 
static void \textbf{ Fetch\+Server\+Timestamp} ()
\begin{DoxyCompactList}\small\item\em Refreshes the server timestamp (async operation, takes a roundtrip). \end{DoxyCompactList}\item 
static void \textbf{ Send\+All\+Outgoing\+Commands} ()
\begin{DoxyCompactList}\small\item\em Can be used to immediately send the RPCs and Instantiates just called, so they are on their way to the other players. \end{DoxyCompactList}\item 
static bool \textbf{ Close\+Connection} (\textbf{ Player} kick\+Player)
\begin{DoxyCompactList}\small\item\em Request a client to disconnect/kick, which happens if Enable\+Close\+Connection is set to true. \end{DoxyCompactList}\item 
static bool \textbf{ Set\+Master\+Client} (\textbf{ Player} master\+Client\+Player)
\begin{DoxyCompactList}\small\item\em Asks the server to assign another player as Master Client of your current room. \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Random\+Room} ()
\begin{DoxyCompactList}\small\item\em Joins a random room that matches the filter. \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Random\+Room} (\textbf{ Hashtable} expected\+Custom\+Room\+Properties, byte expected\+Max\+Players)
\begin{DoxyCompactList}\small\item\em Joins a random room that matches the filter. \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Random\+Room} (\textbf{ Hashtable} expected\+Custom\+Room\+Properties, byte expected\+Max\+Players, \textbf{ Matchmaking\+Mode} matching\+Type, \textbf{ Typed\+Lobby} typed\+Lobby, string sql\+Lobby\+Filter, string[$\,$] expected\+Users=null)
\begin{DoxyCompactList}\small\item\em Joins a random room that matches the filter. \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Random\+Or\+Create\+Room} (\textbf{ Hashtable} expected\+Custom\+Room\+Properties=null, byte expected\+Max\+Players=0, \textbf{ Matchmaking\+Mode} matching\+Type=Matchmaking\+Mode.\+Fill\+Room, \textbf{ Typed\+Lobby} typed\+Lobby=null, string sql\+Lobby\+Filter=null, string room\+Name=null, \textbf{ Room\+Options} room\+Options=null, string[$\,$] expected\+Users=null)
\begin{DoxyCompactList}\small\item\em Attempts to join a room that matches the specified filter and creates a room if none found. \end{DoxyCompactList}\item 
static bool \textbf{ Create\+Room} (string room\+Name, \textbf{ Room\+Options} room\+Options=null, \textbf{ Typed\+Lobby} typed\+Lobby=null, string[$\,$] expected\+Users=null)
\begin{DoxyCompactList}\small\item\em Creates a new room. \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Or\+Create\+Room} (string room\+Name, \textbf{ Room\+Options} room\+Options, \textbf{ Typed\+Lobby} typed\+Lobby, string[$\,$] expected\+Users=null)
\begin{DoxyCompactList}\small\item\em Joins a specific room by name and creates it on demand. \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Room} (string room\+Name, string[$\,$] expected\+Users=null)
\begin{DoxyCompactList}\small\item\em Joins a room by name. \end{DoxyCompactList}\item 
static bool \textbf{ Rejoin\+Room} (string room\+Name)
\begin{DoxyCompactList}\small\item\em Rejoins a room by room\+Name (using the user\+ID internally to return). \end{DoxyCompactList}\item 
static bool \textbf{ Reconnect\+And\+Rejoin} ()
\begin{DoxyCompactList}\small\item\em When the client lost connection during gameplay, this method attempts to reconnect and rejoin the room. \end{DoxyCompactList}\item 
static bool \textbf{ Leave\+Room} (bool become\+Inactive=true)
\begin{DoxyCompactList}\small\item\em Leave the current room and return to the Master Server where you can join or create rooms (see remarks). \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Lobby} ()
\begin{DoxyCompactList}\small\item\em On Master\+Server this joins the default lobby which list rooms currently in use. \end{DoxyCompactList}\item 
static bool \textbf{ Join\+Lobby} (\textbf{ Typed\+Lobby} typed\+Lobby)
\begin{DoxyCompactList}\small\item\em On a Master Server you can join a lobby to get lists of available rooms. \end{DoxyCompactList}\item 
static bool \textbf{ Leave\+Lobby} ()
\begin{DoxyCompactList}\small\item\em Leave a lobby to stop getting updates about available rooms. \end{DoxyCompactList}\item 
static bool \textbf{ Find\+Friends} (string[$\,$] friends\+To\+Find)
\begin{DoxyCompactList}\small\item\em Requests the rooms and online status for a list of friends and saves the result in Photon\+Network.\+Friends. \end{DoxyCompactList}\item 
static bool \textbf{ Get\+Custom\+Room\+List} (\textbf{ Typed\+Lobby} typed\+Lobby, string sql\+Lobby\+Filter)
\begin{DoxyCompactList}\small\item\em Fetches a custom list of games from the server, matching a (non-\/empty) SQL-\/like filter. \end{DoxyCompactList}\item 
static bool \textbf{ Set\+Player\+Custom\+Properties} (\textbf{ Hashtable} custom\+Properties)
\begin{DoxyCompactList}\small\item\em Sets this (local) player\textquotesingle{}s properties and synchronizes them to the other players (don\textquotesingle{}t modify them directly). \end{DoxyCompactList}\item 
static void \textbf{ Remove\+Player\+Custom\+Properties} (string[$\,$] custom\+Properties\+To\+Delete)
\begin{DoxyCompactList}\small\item\em Locally removes Custom Properties of \char`\"{}this\char`\"{} player. \end{DoxyCompactList}\item 
static bool \textbf{ Raise\+Event} (byte event\+Code, object event\+Content, \textbf{ Raise\+Event\+Options} raise\+Event\+Options, Send\+Options send\+Options)
\begin{DoxyCompactList}\small\item\em Sends fully customizable events in a room. \end{DoxyCompactList}\item 
static bool \textbf{ Allocate\+View\+ID} (\textbf{ Photon\+View} view)
\begin{DoxyCompactList}\small\item\em Allocates a view\+ID for the current/local player. \end{DoxyCompactList}\item 
static bool \textbf{ Allocate\+Scene\+View\+ID} (\textbf{ Photon\+View} view)
\item 
static bool \textbf{ Allocate\+Room\+View\+ID} (\textbf{ Photon\+View} view)
\begin{DoxyCompactList}\small\item\em Enables the Master Client to allocate a view\+ID for room objects. \end{DoxyCompactList}\item 
static int \textbf{ Allocate\+View\+ID} (bool room\+Object)
\begin{DoxyCompactList}\small\item\em Allocates a view\+ID for the current/local player or the room. \end{DoxyCompactList}\item 
static int \textbf{ Allocate\+View\+ID} (int owner\+Id)
\begin{DoxyCompactList}\small\item\em Allocates a view\+ID for the current/local player or the room. \end{DoxyCompactList}\item 
static Game\+Object \textbf{ Instantiate} (string prefab\+Name, Vector3 position, Quaternion rotation, byte group=0, object[$\,$] data=null)
\item 
static Game\+Object \textbf{ Instantiate\+Scene\+Object} (string prefab\+Name, Vector3 position, Quaternion rotation, byte group=0, object[$\,$] data=null)
\item 
static Game\+Object \textbf{ Instantiate\+Room\+Object} (string prefab\+Name, Vector3 position, Quaternion rotation, byte group=0, object[$\,$] data=null)
\item 
static void \textbf{ Destroy} (\textbf{ Photon\+View} target\+View)
\begin{DoxyCompactList}\small\item\em Network-\/\+Destroy the Game\+Object associated with the \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}, unless the \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} is static or not under this client\textquotesingle{}s control. \end{DoxyCompactList}\item 
static void \textbf{ Destroy} (Game\+Object target\+Go)
\begin{DoxyCompactList}\small\item\em Network-\/\+Destroy the Game\+Object, unless it is static or not under this client\textquotesingle{}s control. \end{DoxyCompactList}\item 
static void \textbf{ Destroy\+Player\+Objects} (\textbf{ Player} target\+Player)
\begin{DoxyCompactList}\small\item\em Network-\/\+Destroy all Game\+Objects, Photon\+Views and their RPCs of target\+Player. \end{DoxyCompactList}\item 
static void \textbf{ Destroy\+Player\+Objects} (int target\+Player\+Id)
\begin{DoxyCompactList}\small\item\em Network-\/\+Destroy all Game\+Objects, Photon\+Views and their RPCs of this player (by ID). \end{DoxyCompactList}\item 
static void \textbf{ Destroy\+All} ()
\begin{DoxyCompactList}\small\item\em Network-\/\+Destroy all Game\+Objects, Photon\+Views and their RPCs in the room. \end{DoxyCompactList}\item 
static void \textbf{ Remove\+RPCs} (\textbf{ Player} target\+Player)
\begin{DoxyCompactList}\small\item\em Remove all buffered RPCs from server that were sent by target\+Player. \end{DoxyCompactList}\item 
static void \textbf{ Remove\+RPCs} (\textbf{ Photon\+View} target\+Photon\+View)
\begin{DoxyCompactList}\small\item\em Remove all buffered RPCs from server that were sent via target\+Photon\+View. \end{DoxyCompactList}\item 
static Hash\+Set$<$ Game\+Object $>$ \textbf{ Find\+Game\+Objects\+With\+Component} (Type type)
\begin{DoxyCompactList}\small\item\em Finds the Game\+Objects with Components of a specific type (using Find\+Objects\+Of\+Type). \end{DoxyCompactList}\item 
static void \textbf{ Set\+Interest\+Groups} (byte group, bool enabled)
\begin{DoxyCompactList}\small\item\em Enable/disable receiving events from a given Interest Group. \end{DoxyCompactList}\item 
static void \textbf{ Load\+Level} (int level\+Number)
\begin{DoxyCompactList}\small\item\em This method wraps loading a level asynchronously and pausing network messages during the process. \end{DoxyCompactList}\item 
static void \textbf{ Load\+Level} (string level\+Name)
\begin{DoxyCompactList}\small\item\em This method wraps loading a level asynchronously and pausing network messages during the process. \end{DoxyCompactList}\item 
static bool \textbf{ Web\+Rpc} (string name, object parameters, bool send\+Auth\+Cookie=false)
\begin{DoxyCompactList}\small\item\em This operation makes \doxyref{Photon}{p.}{namespace_photon} call your custom web-\/service by name (path) with the given parameters. \end{DoxyCompactList}\item 
static void \textbf{ Load\+Or\+Create\+Settings} (bool reload=false)
\item 
static void \textbf{ Set\+Player\+Custom\+Properties} (\textbf{ System.\+Collections.\+Hashtable} hash)
\item 
static void \textbf{ Add\+Callback\+Target} (object target)
\begin{DoxyCompactList}\small\item\em Registers an object for callbacks for the implemented callback-\/interfaces. \end{DoxyCompactList}\item 
static void \textbf{ Remove\+Callback\+Target} (object target)
\begin{DoxyCompactList}\small\item\em Removes the target object from callbacks for its implemented callback-\/interfaces. \end{DoxyCompactList}\item 
static void \textbf{ Destroy\+Player\+Objects} (int player\+Id, bool local\+Only)
\begin{DoxyCompactList}\small\item\em Destroys all Instantiates and RPCs locally and (if not local\+Only) sends Ev\+Destroy(player) and clears related events in the server buffer. \end{DoxyCompactList}\item 
static void \textbf{ Destroy\+All} (bool local\+Only)
\item 
static bool \textbf{ Local\+Clean\+Photon\+View} (\textbf{ Photon\+View} view)
\item 
static \textbf{ Photon\+View} \textbf{ Get\+Photon\+View} (int view\+ID)
\item 
static void \textbf{ Register\+Photon\+View} (\textbf{ Photon\+View} net\+View)
\item 
static void \textbf{ Op\+Clean\+Actor\+Rpc\+Buffer} (int actor\+Number)
\begin{DoxyCompactList}\small\item\em Removes the RPCs of someone else (to be used as master). \end{DoxyCompactList}\item 
static void \textbf{ Op\+Remove\+Complete\+Cache\+Of\+Player} (int actor\+Number)
\begin{DoxyCompactList}\small\item\em Instead removing RPCs or Instantiates, this removed everything cached by the actor. \end{DoxyCompactList}\item 
static void \textbf{ Op\+Remove\+Complete\+Cache} ()
\item 
static void \textbf{ Clean\+Rpc\+Buffer\+If\+Mine} (\textbf{ Photon\+View} view)
\item 
static void \textbf{ Op\+Clean\+Rpc\+Buffer} (\textbf{ Photon\+View} view)
\begin{DoxyCompactList}\small\item\em Cleans server RPCs for \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} (without any further checks).\end{DoxyCompactList}\item 
static void \textbf{ Remove\+RPCs\+In\+Group} (int group)
\begin{DoxyCompactList}\small\item\em Remove all buffered RPCs from server that were sent in the target\+Group, if this is the Master Client or if this controls the individual \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}. \end{DoxyCompactList}\item 
static bool \textbf{ Remove\+Buffered\+RPCs} (int view\+Id=0, string method\+Name=null, int[$\,$] callers\+Actor\+Numbers=null)
\begin{DoxyCompactList}\small\item\em Clear buffered RPCs based on filter parameters. \end{DoxyCompactList}\item 
static void \textbf{ Set\+Level\+Prefix} (byte prefix)
\begin{DoxyCompactList}\small\item\em Sets level prefix for Photon\+Views instantiated later on. \end{DoxyCompactList}\item 
static void \textbf{ Set\+Interest\+Groups} (byte[$\,$] disable\+Groups, byte[$\,$] enable\+Groups)
\begin{DoxyCompactList}\small\item\em Enable/disable receiving on given Interest Groups (applied to Photon\+Views). \end{DoxyCompactList}\item 
static void \textbf{ Set\+Sending\+Enabled} (byte group, bool enabled)
\begin{DoxyCompactList}\small\item\em Enable/disable sending on given group (applied to Photon\+Views)\end{DoxyCompactList}\item 
static void \textbf{ Set\+Sending\+Enabled} (byte[$\,$] disable\+Groups, byte[$\,$] enable\+Groups)
\begin{DoxyCompactList}\small\item\em Enable/disable sending on given groups (applied to Photon\+Views)\end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
const string \textbf{ Pun\+Version} = \char`\"{}2.\+40\char`\"{}
\begin{DoxyCompactList}\small\item\em Version number of PUN. Used in the App\+Version, which separates your playerbase in matchmaking.\end{DoxyCompactList}\item 
static \textbf{ Load\+Balancing\+Client} \textbf{ Networking\+Client}
\begin{DoxyCompactList}\small\item\em The Load\+Balancing\+Client is part of \doxyref{Photon}{p.}{namespace_photon} \doxyref{Realtime}{p.}{namespace_photon_1_1_realtime} and wraps up multiple servers and states for PUN.\end{DoxyCompactList}\item 
static readonly int \textbf{ MAX\+\_\+\+VIEW\+\_\+\+IDS} = 1000
\begin{DoxyCompactList}\small\item\em The maximum number of assigned Photon\+Views {\itshape per player} (or scene). \end{DoxyCompactList}\item 
const string \textbf{ Server\+Settings\+File\+Name} = \char`\"{}Photon\+Server\+Settings\char`\"{}
\begin{DoxyCompactList}\small\item\em Name of the Photon\+Server\+Settings file (used to load and by \doxyref{Photon\+Editor}{p.}{class_photon_1_1_pun_1_1_photon_editor} to save new files).\end{DoxyCompactList}\item 
static \textbf{ Connect\+Method} \textbf{ Connect\+Method} = \textbf{ Connect\+Method.\+Not\+Called}
\begin{DoxyCompactList}\small\item\em Tracks, which Connect method was called last. \end{DoxyCompactList}\item 
static \textbf{ Pun\+Log\+Level} \textbf{ Log\+Level} = \textbf{ Pun\+Log\+Level.\+Errors\+Only}
\begin{DoxyCompactList}\small\item\em Controls how verbose PUN is. \end{DoxyCompactList}\item 
static bool \textbf{ Enable\+Close\+Connection} = false
\begin{DoxyCompactList}\small\item\em Used to enable reaction to Close\+Connection events. \end{DoxyCompactList}\item 
static float \textbf{ Precision\+For\+Vector\+Synchronization} = 0.\+000099f
\begin{DoxyCompactList}\small\item\em The minimum difference that a Vector2 or Vector3(e.\+g. \end{DoxyCompactList}\item 
static float \textbf{ Precision\+For\+Quaternion\+Synchronization} = 1.\+0f
\begin{DoxyCompactList}\small\item\em The minimum angle that a rotation needs to change before we send it via a \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}\textquotesingle{}s On\+Serialize/\+Observing\+Component. \end{DoxyCompactList}\item 
static float \textbf{ Precision\+For\+Float\+Synchronization} = 0.\+01f
\begin{DoxyCompactList}\small\item\em The minimum difference between floats before we send it via a \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}\textquotesingle{}s On\+Serialize/\+Observing\+Component. \end{DoxyCompactList}\item 
static float \textbf{ Minimal\+Time\+Scale\+To\+Dispatch\+In\+Fixed\+Update} = -\/1f
\begin{DoxyCompactList}\small\item\em Affects if the \doxyref{Photon\+Handler}{p.}{class_photon_1_1_pun_1_1_photon_handler} dispatches incoming messages in Late\+Update or Fixed\+Update (default). \end{DoxyCompactList}\item 
static bool \textbf{ Use\+Rpc\+Mono\+Behaviour\+Cache}
\begin{DoxyCompactList}\small\item\em While enabled, the Mono\+Behaviours on which we call RPCs are cached, avoiding costly Get\+Components\texorpdfstring{$<$}{<}Mono\+Behaviour\texorpdfstring{$>$}{>}() calls. \end{DoxyCompactList}\item 
static bool \textbf{ Run\+Rpc\+Coroutines} = true
\begin{DoxyCompactList}\small\item\em If an RPC method is implemented as coroutine, it gets started, unless this value is false. \end{DoxyCompactList}\item 
static int \textbf{ Objects\+In\+One\+Update} = 20
\begin{DoxyCompactList}\small\item\em Defines how many updated produced by On\+Photon\+Serialize() are batched into one message. \end{DoxyCompactList}\item 
const int \textbf{ Sync\+View\+Id} = 0
\item 
const int \textbf{ Sync\+Compressed} = 1
\item 
const int \textbf{ Sync\+Null\+Values} = 2
\item 
const int \textbf{ Sync\+First\+Value} = 3
\end{DoxyCompactItemize}
\doxysubsection*{Properties}
\begin{DoxyCompactItemize}
\item 
static string \textbf{ Game\+Version}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Version number of your game. \end{DoxyCompactList}\item 
static string \textbf{ App\+Version}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Sent to \doxyref{Photon}{p.}{namespace_photon} Server to specify the \char`\"{}\+Virtual App\+Id\char`\"{}. \end{DoxyCompactList}\item 
static \textbf{ Server\+Settings} \textbf{ Photon\+Server\+Settings}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Serialized server settings, written by the Setup Wizard for use in Connect\+Using\+Settings.\end{DoxyCompactList}\item 
static string? \textbf{ Server\+Address}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Currently used server address (no matter if master or game server).\end{DoxyCompactList}\item 
static string? \textbf{ Cloud\+Region}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Currently used Cloud Region (if any). As long as the client is not on a Master Server or Game Server, the region is not yet defined.\end{DoxyCompactList}\item 
static string? \textbf{ Current\+Cluster}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The cluster name provided by the Name Server. \end{DoxyCompactList}\item 
static string \textbf{ Best\+Region\+Summary\+In\+Preferences}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Used to store and access the \char`\"{}\+Best Region Summary\char`\"{} in the Player Preferences. \end{DoxyCompactList}\item 
static bool \textbf{ Is\+Connected}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em False until you connected to \doxyref{Photon}{p.}{namespace_photon} initially. \end{DoxyCompactList}\item 
static bool \textbf{ Is\+Connected\+And\+Ready}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em A refined version of connected which is true only if your connection to the server is ready to accept operations like join, leave, etc. \end{DoxyCompactList}\item 
static \textbf{ Client\+State}? \textbf{ Network\+Client\+State}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Directly provides the network-\/level client state, unless in Offline\+Mode. \end{DoxyCompactList}\item 
static \textbf{ Server\+Connection}?? \textbf{ Server}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The server (type) this client is currently connected or connecting to. \end{DoxyCompactList}\item 
static \textbf{ Authentication\+Values}? \textbf{ Auth\+Values}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em A user\textquotesingle{}s authentication values used during connect. \end{DoxyCompactList}\item 
static \textbf{ Typed\+Lobby} \textbf{ Current\+Lobby}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The lobby that will be used when PUN joins a lobby or creates a game. \end{DoxyCompactList}\item 
static \textbf{ Room}? \textbf{ Current\+Room}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Get the room we\textquotesingle{}re currently in (also when in Offline\+Mode). \end{DoxyCompactList}\item 
static \textbf{ Player} \textbf{ Local\+Player}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em This client\textquotesingle{}s Player instance is always available, unless the app shuts down. \end{DoxyCompactList}\item 
static string \textbf{ Nick\+Name}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Set to synchronize the player\textquotesingle{}s nickname with everyone in the room(s) you enter. \end{DoxyCompactList}\item 
static \textbf{ Player}[$\,$] \textbf{ Player\+List}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em A sorted copy of the players-\/list of the current room. \end{DoxyCompactList}\item 
static \textbf{ Player}[$\,$] \textbf{ Player\+List\+Others}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em A sorted copy of the players-\/list of the current room, excluding this client. \end{DoxyCompactList}\item 
static bool \textbf{ Offline\+Mode}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Offline mode can be set to re-\/use your multiplayer code in singleplayer game modes. \end{DoxyCompactList}\item 
static bool \textbf{ Automatically\+Sync\+Scene}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Defines if all clients in a room should automatically load the same level as the Master Client. \end{DoxyCompactList}\item 
static bool \textbf{ Enable\+Lobby\+Statistics}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em If enabled, the client will get a list of available lobbies from the Master Server. \end{DoxyCompactList}\item 
static bool \textbf{ In\+Lobby}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em True while this client is in a lobby. \end{DoxyCompactList}\item 
static int \textbf{ Send\+Rate}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Defines how many times per second the \doxyref{Photon\+Handler}{p.}{class_photon_1_1_pun_1_1_photon_handler} should send data, if any is queued. \end{DoxyCompactList}\item 
static int \textbf{ Serialization\+Rate}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Defines how many times per second On\+Photon\+Serialize should be called on Photon\+Views for controlled objects. \end{DoxyCompactList}\item 
static bool \textbf{ Is\+Message\+Queue\+Running}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Can be used to pause dispatching of incoming events (RPCs, Instantiates and anything else incoming). \end{DoxyCompactList}\item 
static double \textbf{ Time}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em \doxyref{Photon}{p.}{namespace_photon} network time, synched with the server. \end{DoxyCompactList}\item 
static int \textbf{ Server\+Timestamp}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The current server\textquotesingle{}s millisecond timestamp. \end{DoxyCompactList}\item 
static float? \textbf{ Keep\+Alive\+In\+Background}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Defines how many seconds PUN keeps the connection after Unity\textquotesingle{}s On\+Application\+Pause(true) call. \end{DoxyCompactList}\item 
static bool \textbf{ Is\+Master\+Client}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Are we the master client? \end{DoxyCompactList}\item 
static \textbf{ Player} \textbf{ Master\+Client}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The Master Client of the current room or null (outside of rooms). \end{DoxyCompactList}\item 
static bool \textbf{ In\+Room}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Is true while being in a room (Network\+Client\+State == Client\+State.\+Joined). \end{DoxyCompactList}\item 
static int \textbf{ Count\+Of\+Players\+On\+Master}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The count of players currently looking for a room (available on Master\+Server in 5sec intervals). \end{DoxyCompactList}\item 
static int \textbf{ Count\+Of\+Players\+In\+Rooms}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Count of users currently playing your app in some room (sent every 5sec by Master Server). \end{DoxyCompactList}\item 
static int \textbf{ Count\+Of\+Players}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The count of players currently using this application (available on Master\+Server in 5sec intervals). \end{DoxyCompactList}\item 
static int \textbf{ Count\+Of\+Rooms}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em The count of rooms currently in use (available on Master\+Server in 5sec intervals). \end{DoxyCompactList}\item 
static bool \textbf{ Network\+Statistics\+Enabled}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Enables or disables the collection of statistics about this client\textquotesingle{}s traffic. \end{DoxyCompactList}\item 
static int \textbf{ Resent\+Reliable\+Commands}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Count of commands that got repeated (due to local repeat-\/timing before an ACK was received). \end{DoxyCompactList}\item 
static bool \textbf{ Crc\+Check\+Enabled}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Crc checks can be useful to detect and avoid issues with broken datagrams. Can be enabled while not connected.\end{DoxyCompactList}\item 
static int \textbf{ Packet\+Loss\+By\+Crc\+Check}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em If Crc\+Check\+Enabled, this counts the incoming packages that don\textquotesingle{}t have a valid CRC checksum and got rejected.\end{DoxyCompactList}\item 
static int \textbf{ Max\+Resends\+Before\+Disconnect}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Defines the number of times a reliable message can be resent before not getting an ACK for it will trigger a disconnect. \end{DoxyCompactList}\item 
static int \textbf{ Quick\+Resends}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em In case of network loss, reliable messages can be repeated quickly up to 3 times. \end{DoxyCompactList}\item 
static bool \textbf{ Use\+Alternative\+Udp\+Ports}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Replaced by Server\+Port\+Overrides.\end{DoxyCompactList}\item 
static \textbf{ Photon\+Port\+Definition}? \textbf{ Server\+Port\+Overrides}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em Defines overrides for server ports. \end{DoxyCompactList}\item 
static \textbf{ Photon\+View}[$\,$] \textbf{ Photon\+Views}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Gets the photon views. \end{DoxyCompactList}\item 
static Non\+Alloc\+Dictionary$<$ int, \textbf{ Photon\+View} $>$.Value\+Iterator \textbf{ Photon\+View\+Collection}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Returns a new iterable collection of current photon views. \end{DoxyCompactList}\item 
static int \textbf{ View\+Count}\hspace{0.3cm}{\ttfamily  [get]}
\item 
static \textbf{ IPun\+Prefab\+Pool} \textbf{ Prefab\+Pool}\hspace{0.3cm}{\ttfamily  [getset]}
\begin{DoxyCompactList}\small\item\em An Object Pool can be used to keep and reuse instantiated object instances. \end{DoxyCompactList}\item 
static float \textbf{ Level\+Loading\+Progress}\hspace{0.3cm}{\ttfamily  [get]}
\begin{DoxyCompactList}\small\item\em Represents the scene loading progress when using \doxyref{Load\+Level()}{p.}{class_photon_1_1_pun_1_1_photon_network_a9aa7d7a2389b180e95c81921076ac056}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The main class to use the \doxyref{Photon\+Network}{p.}{class_photon_1_1_pun_1_1_photon_network} plugin. 

This class is static. 

Definition at line \textbf{ 64} of file \textbf{ Photon\+Network.\+cs}.



\doxysubsection{Member Function Documentation}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ab6df1ed60be8a3f494683b8faa28ee4a}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AddCallbackTarget@{AddCallbackTarget}}
\index{AddCallbackTarget@{AddCallbackTarget}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AddCallbackTarget()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Add\+Callback\+Target (\begin{DoxyParamCaption}\item[{object}]{target }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Registers an object for callbacks for the implemented callback-\/interfaces. 

The covered callback interfaces are\+: IConnection\+Callbacks, IMatchmaking\+Callbacks, ILobby\+Callbacks, IIn\+Room\+Callbacks, IOn\+Event\+Callback and IWeb\+Rpc\+Callback.

See\+: {\texttt{ .Net Callbacks}} 


\begin{DoxyParams}{Parameters}
{\em target} & The object that registers to get callbacks from PUN\textquotesingle{}s Load\+Balancing\+Client.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 106} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ab6df1ed60be8a3f494683b8faa28ee4a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ab6df1ed60be8a3f494683b8faa28ee4a_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a8193e279f3ca157cbadeff44e1568a8b}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AllocateRoomViewID@{AllocateRoomViewID}}
\index{AllocateRoomViewID@{AllocateRoomViewID}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AllocateRoomViewID()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Allocate\+Room\+View\+ID (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Enables the Master Client to allocate a view\+ID for room objects. 

\begin{DoxyReturn}{Returns}
True if a view\+Id was assigned. False if the \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} already had a non-\/zero view\+ID or if this client is not the Master Client.
\end{DoxyReturn}


Definition at line \textbf{ 2382} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a8193e279f3ca157cbadeff44e1568a8b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a8193e279f3ca157cbadeff44e1568a8b_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a6a88396fedad4f37ff61e289b180559e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AllocateSceneViewID@{AllocateSceneViewID}}
\index{AllocateSceneViewID@{AllocateSceneViewID}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AllocateSceneViewID()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Allocate\+Scene\+View\+ID (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 2373} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a6a88396fedad4f37ff61e289b180559e_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac4a4aef738ff76e949df098847e9e3fe}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AllocateViewID@{AllocateViewID}}
\index{AllocateViewID@{AllocateViewID}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AllocateViewID()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static int Photon.\+Pun.\+Photon\+Network.\+Allocate\+View\+ID (\begin{DoxyParamCaption}\item[{bool}]{room\+Object }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Allocates a view\+ID for the current/local player or the room. 


\begin{DoxyParams}{Parameters}
{\em room\+Object} & Use true, to allocate a room view\+ID and false to allocate a view\+ID for the local player.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a view\+ID (combined owner and sequential number) that can be assigned as \doxyref{Photon\+View.\+View\+ID}{p.}{class_photon_1_1_pun_1_1_photon_view_a5ed698bf9795e566e9ff343a507de85f}.
\end{DoxyReturn}


Definition at line \textbf{ 2404} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ac4a4aef738ff76e949df098847e9e3fe_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3a45a00ed2210c47ccea385eee054177}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AllocateViewID@{AllocateViewID}}
\index{AllocateViewID@{AllocateViewID}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AllocateViewID()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static int Photon.\+Pun.\+Photon\+Network.\+Allocate\+View\+ID (\begin{DoxyParamCaption}\item[{int}]{owner\+Id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Allocates a view\+ID for the current/local player or the room. 


\begin{DoxyParams}{Parameters}
{\em owner\+Id} & Actor\+Number to allocate a view\+ID for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a view\+ID (combined owner and sequential number) that can be assigned as \doxyref{Photon\+View.\+View\+ID}{p.}{class_photon_1_1_pun_1_1_photon_view_a5ed698bf9795e566e9ff343a507de85f}.
\end{DoxyReturn}


Definition at line \textbf{ 2419} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac9f5c2c968dc23f337092fedff586132}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AllocateViewID@{AllocateViewID}}
\index{AllocateViewID@{AllocateViewID}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AllocateViewID()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Allocate\+View\+ID (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Allocates a view\+ID for the current/local player. 

\begin{DoxyReturn}{Returns}
True if a view\+Id was assigned. False if the \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} already had a non-\/zero view\+ID.
\end{DoxyReturn}


Definition at line \textbf{ 2359} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ac9f5c2c968dc23f337092fedff586132_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ac9f5c2c968dc23f337092fedff586132_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_acf94c5d71fe4fc49213ff466d5613dce}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CleanRpcBufferIfMine@{CleanRpcBufferIfMine}}
\index{CleanRpcBufferIfMine@{CleanRpcBufferIfMine}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CleanRpcBufferIfMine()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Clean\+Rpc\+Buffer\+If\+Mine (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 1075} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_acf94c5d71fe4fc49213ff466d5613dce_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_acf94c5d71fe4fc49213ff466d5613dce_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a988b591a3d496808e1d7c79a5bfaa70e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CloseConnection@{CloseConnection}}
\index{CloseConnection@{CloseConnection}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CloseConnection()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Close\+Connection (\begin{DoxyParamCaption}\item[{\textbf{ Player}}]{kick\+Player }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Request a client to disconnect/kick, which happens if Enable\+Close\+Connection is set to true. 

Only the master client can do this.

Only the target player gets this event. That player will disconnect if Enable\+Close\+Connection = true.


\begin{DoxyParams}{Parameters}
{\em kick\+Player} & The Player to kick.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1501} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a988b591a3d496808e1d7c79a5bfaa70e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a988b591a3d496808e1d7c79a5bfaa70e_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ad3c8b7c177d986ceea13dbfb858a4a79}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ConnectToBestCloudServer@{ConnectToBestCloudServer}}
\index{ConnectToBestCloudServer@{ConnectToBestCloudServer}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ConnectToBestCloudServer()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Connect\+To\+Best\+Cloud\+Server (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Connect to the \doxyref{Photon}{p.}{namespace_photon} Cloud region with the lowest ping (on platforms that support Unity\textquotesingle{}s Ping). 

Will save the result of pinging all cloud servers in Player\+Prefs. Calling this the first time can take +-\/2 seconds. The ping result can be overridden via Photon\+Network.\+Override\+Best\+Cloud\+Server(..) This call can take up to 2 seconds if it is the first time you are using this, all cloud servers will be pinged to check for the best region.

The PUN Setup Wizard stores your app\+ID in a settings file and applies a server address/port. To connect to the \doxyref{Photon}{p.}{namespace_photon} Cloud, a valid App\+Id must be in the settings file (shown in the \doxyref{Photon}{p.}{namespace_photon} Cloud Dashboard). {\texttt{ https\+://dashboard.\+photonengine.\+com}}

Connecting to the \doxyref{Photon}{p.}{namespace_photon} Cloud might fail due to\+:
\begin{DoxyItemize}
\item Invalid App\+Id
\item Network issues
\item Invalid region
\item Subscription CCU limit reached
\item etc.
\end{DoxyItemize}

In general check out the Disconnect\+Cause from the \doxyref{IConnection\+Callbacks.\+On\+Disconnected}{p.}{interface_photon_1_1_realtime_1_1_i_connection_callbacks_a5e133a672790851ab0554fdc821c7727} callback. 

\begin{DoxyReturn}{Returns}
If this client is going to connect to cloud server based on ping. Even if true, this does not guarantee a connection but the attempt is being made.
\end{DoxyReturn}


Definition at line \textbf{ 1290} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ad3c8b7c177d986ceea13dbfb858a4a79_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ad3c8b7c177d986ceea13dbfb858a4a79_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aec6b6dd3b56678c58175e5d2a4cb5661}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ConnectToMaster@{ConnectToMaster}}
\index{ConnectToMaster@{ConnectToMaster}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ConnectToMaster()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Connect\+To\+Master (\begin{DoxyParamCaption}\item[{string}]{master\+Server\+Address,  }\item[{int}]{port,  }\item[{string}]{app\+ID }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Connect to a \doxyref{Photon}{p.}{namespace_photon} Master Server by address, port, app\+ID. 

To connect to the \doxyref{Photon}{p.}{namespace_photon} Cloud, a valid App\+Id must be in the settings file (shown in the \doxyref{Photon}{p.}{namespace_photon} Cloud Dashboard). {\texttt{ https\+://dashboard.\+photonengine.\+com}}

Connecting to the \doxyref{Photon}{p.}{namespace_photon} Cloud might fail due to\+:
\begin{DoxyItemize}
\item Invalid App\+Id
\item Network issues
\item Invalid region
\item Subscription CCU limit reached
\item etc.
\end{DoxyItemize}

In general check out the Disconnect\+Cause from the \doxyref{IConnection\+Callbacks.\+On\+Disconnected}{p.}{interface_photon_1_1_realtime_1_1_i_connection_callbacks_a5e133a672790851ab0554fdc821c7727} callback. 


\begin{DoxyParams}{Parameters}
{\em master\+Server\+Address} & The server\textquotesingle{}s address (either your own or \doxyref{Photon}{p.}{namespace_photon} Cloud address).\\
\hline
{\em port} & The server\textquotesingle{}s port to connect to.\\
\hline
{\em app\+ID} & Your application ID (\doxyref{Photon}{p.}{namespace_photon} Cloud provides you with a GUID for your game).\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1231} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aec6b6dd3b56678c58175e5d2a4cb5661_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aec6b6dd3b56678c58175e5d2a4cb5661_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a37971483afa605d0d1383970b11f8cec}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ConnectToRegion@{ConnectToRegion}}
\index{ConnectToRegion@{ConnectToRegion}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ConnectToRegion()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Connect\+To\+Region (\begin{DoxyParamCaption}\item[{string}]{region }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Connects to the \doxyref{Photon}{p.}{namespace_photon} Cloud region of choice. 

It\textquotesingle{}s typically enough to define the region code (\char`\"{}eu\char`\"{}, \char`\"{}us\char`\"{}, etc). Connecting to a specific cluster may be necessary, when regions get sharded and you support friends / invites.

In all other cases, you should not define a cluster as this allows the Name Server to distribute clients as needed. A random, load balanced cluster will be selected.

The Name Server has the final say to assign a cluster as available. If the requested cluster is not available another will be assigned.

Once connected, check the value of Current\+Cluster. 

Definition at line \textbf{ 1327} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a37971483afa605d0d1383970b11f8cec_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a37971483afa605d0d1383970b11f8cec_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3eaa67a8c2af70028949403df6b60ca2}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ConnectUsingSettings@{ConnectUsingSettings}}
\index{ConnectUsingSettings@{ConnectUsingSettings}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ConnectUsingSettings()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Connect\+Using\+Settings (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Connect to \doxyref{Photon}{p.}{namespace_photon} as configured in the Photon\+Server\+Settings file. 

Implement IConnection\+Callbacks, to make your game logic aware of state changes. Especially, IConnection\+Callbacks.\+Connected\+To\+Master\+Server is useful to react when the client can do matchmaking.

This method will disable Offline\+Mode (which won\textquotesingle{}t destroy any instantiated GOs) and it will set Is\+Message\+Queue\+Running to true.

Your \doxyref{Photon}{p.}{namespace_photon} configuration is created by the PUN Wizard and contains the App\+Id, region for \doxyref{Photon}{p.}{namespace_photon} Cloud games, the server address among other things.

To ignore the settings file, set the relevant values and connect by calling Connect\+To\+Master, Connect\+To\+Region.

To connect to the \doxyref{Photon}{p.}{namespace_photon} Cloud, a valid App\+Id must be in the settings file (shown in the {\texttt{ Photon Cloud Dashboard}}).

Connecting to the \doxyref{Photon}{p.}{namespace_photon} Cloud might fail due to\+:
\begin{DoxyItemize}
\item Invalid App\+Id
\item Network issues
\item Invalid region
\item Subscription CCU limit reached
\item etc.
\end{DoxyItemize}

In general check out the Disconnect\+Cause from the \doxyref{IConnection\+Callbacks.\+On\+Disconnected}{p.}{interface_photon_1_1_realtime_1_1_i_connection_callbacks_a5e133a672790851ab0554fdc821c7727} callback. 

Definition at line \textbf{ 1122} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_a3eaa67a8c2af70028949403df6b60ca2_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a3eaa67a8c2af70028949403df6b60ca2_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae031208b657a2e01d80ddf4b02d0d23f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ConnectUsingSettings@{ConnectUsingSettings}}
\index{ConnectUsingSettings@{ConnectUsingSettings}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ConnectUsingSettings()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Connect\+Using\+Settings (\begin{DoxyParamCaption}\item[{\textbf{ App\+Settings}}]{app\+Settings,  }\item[{bool}]{start\+In\+Offline\+Mode = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 1133} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ae031208b657a2e01d80ddf4b02d0d23f_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a755417a54b55bdb92361dc74b4a09953}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CreateRoom@{CreateRoom}}
\index{CreateRoom@{CreateRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CreateRoom()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Create\+Room (\begin{DoxyParamCaption}\item[{string}]{room\+Name,  }\item[{\textbf{ Room\+Options}}]{room\+Options = {\ttfamily null},  }\item[{\textbf{ Typed\+Lobby}}]{typed\+Lobby = {\ttfamily null},  }\item[{string[$\,$]}]{expected\+Users = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Creates a new room. 

Will callback\+: On\+Created\+Room and On\+Joined\+Room or On\+Create\+Room\+Failed. 

When successful, this calls the callbacks On\+Created\+Room and On\+Joined\+Room (the latter, cause you join as first player). In all error cases, On\+Create\+Room\+Failed gets called.

Creating a room will fail if the room name is already in use or when the Room\+Options clashing with one another. Check the Enter\+Room\+Params reference for the various room creation options.

If you don\textquotesingle{}t want to create a unique room-\/name, pass null or \char`\"{}\char`\"{} as name and the server will assign a room\+Name (a GUID as string).

This method can only be called while the client is connected to a Master Server so you should implement the callback On\+Connected\+To\+Master. Check the return value to make sure the operation will be called on the server. Note\+: There will be no callbacks if this method returned false.

More about PUN matchmaking\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby}} 


\begin{DoxyParams}{Parameters}
{\em room\+Name} & Unique name of the room to create. Pass null or \char`\"{}\char`\"{} to make the server generate a name.\\
\hline
{\em room\+Options} & Common options for the room like Max\+Players, initial custom room properties and similar. See Room\+Options type..\\
\hline
{\em typed\+Lobby} & If null, the room is automatically created in the currently used lobby (which is \char`\"{}default\char`\"{} when you didn\textquotesingle{}t join one explicitly).\\
\hline
{\em expected\+Users} & Optional list of users (by User\+Id) who are expected to join this game and who you want to block a slot for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation got queued and will be sent.
\end{DoxyReturn}


Definition at line \textbf{ 1768} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a755417a54b55bdb92361dc74b4a09953_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a755417a54b55bdb92361dc74b4a09953_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a839b3fdf0a5aa749db1fafeff8d51bdf}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!Destroy@{Destroy}}
\index{Destroy@{Destroy}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{Destroy()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Destroy (\begin{DoxyParamCaption}\item[{Game\+Object}]{target\+Go }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Network-\/\+Destroy the Game\+Object, unless it is static or not under this client\textquotesingle{}s control. 

Destroying a networked Game\+Object includes\+:
\begin{DoxyItemize}
\item Removal of the Instantiate call from the server\textquotesingle{}s room buffer.
\item Removing RPCs buffered for Photon\+Views that got created indirectly with the \doxyref{Photon\+Network.\+Instantiate}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0} call.
\item Sending a message to other clients to remove the Game\+Object also (affected by network lag).
\end{DoxyItemize}

Usually, when you leave a room, the GOs get destroyed automatically. If you have to destroy a GO while not in a room, the Destroy is only done locally.

Destroying networked objects works only if they got created with \doxyref{Photon\+Network.\+Instantiate()}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0}. Objects loaded with a scene are ignored, no matter if they have \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} components.

The Game\+Object must be under this client\textquotesingle{}s control\+:
\begin{DoxyItemize}
\item Instantiated and owned by this client.
\item Instantiated objects of players who left the room are controlled by the Master Client.
\item Room-\/owned game objects are controlled by the Master Client.
\item Game\+Object can be destroyed while client is not in a room. 
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
Nothing. Check error debug log for any issues.
\end{DoxyReturn}


Definition at line \textbf{ 2783} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ada7d7b9bdb306863c66b260dde7c544e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!Destroy@{Destroy}}
\index{Destroy@{Destroy}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{Destroy()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Destroy (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{target\+View }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Network-\/\+Destroy the Game\+Object associated with the \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}, unless the \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} is static or not under this client\textquotesingle{}s control. 

Destroying a networked Game\+Object while in a Room includes\+:
\begin{DoxyItemize}
\item Removal of the Instantiate call from the server\textquotesingle{}s room buffer.
\item Removing RPCs buffered for Photon\+Views that got created indirectly with the \doxyref{Photon\+Network.\+Instantiate}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0} call.
\item Sending a message to other clients to remove the Game\+Object also (affected by network lag).
\end{DoxyItemize}

Usually, when you leave a room, the GOs get destroyed automatically. If you have to destroy a GO while not in a room, the Destroy is only done locally.

Destroying networked objects works only if they got created with \doxyref{Photon\+Network.\+Instantiate()}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0}. Objects loaded with a scene are ignored, no matter if they have \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} components.

The Game\+Object must be under this client\textquotesingle{}s control\+:
\begin{DoxyItemize}
\item Instantiated and owned by this client.
\item Instantiated objects of players who left the room are controlled by the Master Client.
\item Room-\/owned game objects are controlled by the Master Client.
\item Game\+Object can be destroyed while client is not in a room. 
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
Nothing. Check error debug log for any issues.
\end{DoxyReturn}


Definition at line \textbf{ 2749} of file \textbf{ Photon\+Network.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ada7d7b9bdb306863c66b260dde7c544e_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ad2885fef5a61d3561a740f3abf3ab69a}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!DestroyAll@{DestroyAll}}
\index{DestroyAll@{DestroyAll}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{DestroyAll()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Destroy\+All (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Network-\/\+Destroy all Game\+Objects, Photon\+Views and their RPCs in the room. 

Removes anything buffered from the server. Can only be called by Master Client (for anyone). 

Can only be called by Master Client (for anyone). Unlike the Destroy methods, this will remove anything from the server\textquotesingle{}s room buffer. If your game buffers anything beyond Instantiate and RPC calls, that will be cleaned as well from server.

Destroying all includes\+:
\begin{DoxyItemize}
\item Remove anything from the server\textquotesingle{}s room buffer (Instantiate, RPCs, anything buffered).
\item Sending a message to other clients to destroy everything locally, too (affected by network lag).
\end{DoxyItemize}

Destroying networked objects works only if they got created with \doxyref{Photon\+Network.\+Instantiate()}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0}. Objects loaded with a scene are ignored, no matter if they have \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} components. 

\begin{DoxyReturn}{Returns}
Nothing. Check error debug log for any issues.
\end{DoxyReturn}


Definition at line \textbf{ 2856} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_ad2885fef5a61d3561a740f3abf3ab69a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_ad2885fef5a61d3561a740f3abf3ab69a_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a823006ebcd17adacd6a47b5d23c3aaef}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!DestroyAll@{DestroyAll}}
\index{DestroyAll@{DestroyAll}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{DestroyAll()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Destroy\+All (\begin{DoxyParamCaption}\item[{bool}]{local\+Only }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 762} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a823006ebcd17adacd6a47b5d23c3aaef_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_af875d9527ce0aff17d798b7030e7ee98}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!DestroyPlayerObjects@{DestroyPlayerObjects}}
\index{DestroyPlayerObjects@{DestroyPlayerObjects}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{DestroyPlayerObjects()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Destroy\+Player\+Objects (\begin{DoxyParamCaption}\item[{int}]{player\+Id,  }\item[{bool}]{local\+Only }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Destroys all Instantiates and RPCs locally and (if not local\+Only) sends Ev\+Destroy(player) and clears related events in the server buffer. 



Definition at line \textbf{ 703} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_af875d9527ce0aff17d798b7030e7ee98_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a5bc1ff03b1dc2226490bff064aaf6275}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!DestroyPlayerObjects@{DestroyPlayerObjects}}
\index{DestroyPlayerObjects@{DestroyPlayerObjects}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{DestroyPlayerObjects()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Destroy\+Player\+Objects (\begin{DoxyParamCaption}\item[{int}]{target\+Player\+Id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Network-\/\+Destroy all Game\+Objects, Photon\+Views and their RPCs of this player (by ID). 

Can only be called on local player (for \char`\"{}self\char`\"{}) or Master Client (for anyone). 

Destroying a networked Game\+Object includes\+:
\begin{DoxyItemize}
\item Removal of the Instantiate call from the server\textquotesingle{}s room buffer.
\item Removing RPCs buffered for Photon\+Views that got created indirectly with the \doxyref{Photon\+Network.\+Instantiate}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0} call.
\item Sending a message to other clients to remove the Game\+Object also (affected by network lag).
\end{DoxyItemize}

Destroying networked objects works only if they got created with \doxyref{Photon\+Network.\+Instantiate()}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0}. Objects loaded with a scene are ignored, no matter if they have \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} components. 

\begin{DoxyReturn}{Returns}
Nothing. Check error debug log for any issues.
\end{DoxyReturn}


Definition at line \textbf{ 2824} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a5bc1ff03b1dc2226490bff064aaf6275_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aee9bc16543629db01f0879339c1fcc8e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!DestroyPlayerObjects@{DestroyPlayerObjects}}
\index{DestroyPlayerObjects@{DestroyPlayerObjects}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{DestroyPlayerObjects()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Destroy\+Player\+Objects (\begin{DoxyParamCaption}\item[{\textbf{ Player}}]{target\+Player }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Network-\/\+Destroy all Game\+Objects, Photon\+Views and their RPCs of target\+Player. 

Can only be called on local player (for \char`\"{}self\char`\"{}) or Master Client (for anyone). 

Destroying a networked Game\+Object includes\+:
\begin{DoxyItemize}
\item Removal of the Instantiate call from the server\textquotesingle{}s room buffer.
\item Removing RPCs buffered for Photon\+Views that got created indirectly with the \doxyref{Photon\+Network.\+Instantiate}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0} call.
\item Sending a message to other clients to remove the Game\+Object also (affected by network lag).
\end{DoxyItemize}

Destroying networked objects works only if they got created with \doxyref{Photon\+Network.\+Instantiate()}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0}. Objects loaded with a scene are ignored, no matter if they have \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} components. 

\begin{DoxyReturn}{Returns}
Nothing. Check error debug log for any issues.
\end{DoxyReturn}


Definition at line \textbf{ 2801} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_aee9bc16543629db01f0879339c1fcc8e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_aee9bc16543629db01f0879339c1fcc8e_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a1da1c658340e7ecf28575b720104b122}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!Disconnect@{Disconnect}}
\index{Disconnect@{Disconnect}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{Disconnect()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Disconnect (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Makes this client disconnect from the photon server, a process that leaves any room and calls On\+Disconnected on completion. 

When you disconnect, the client will send a \char`\"{}disconnecting\char`\"{} message to the server. This speeds up leave/disconnect messages for players in the same room as you (otherwise the server would timeout this client\textquotesingle{}s connection). When used in Offline\+Mode, the state-\/change and event-\/call On\+Disconnected are immediate. Offline mode is set to false as well. Once disconnected, the client can connect again. Use Connect\+Using\+Settings. 

Definition at line \textbf{ 1362} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a1da1c658340e7ecf28575b720104b122_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a1da1c658340e7ecf28575b720104b122_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a27f9f9fce63f7130b2aeff5eb3d9efed}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!FetchServerTimestamp@{FetchServerTimestamp}}
\index{FetchServerTimestamp@{FetchServerTimestamp}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{FetchServerTimestamp()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Fetch\+Server\+Timestamp (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Refreshes the server timestamp (async operation, takes a roundtrip). 

Can be useful if a bad connection made the timestamp unusable or imprecise.

Definition at line \textbf{ 1469} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac3ef7244ebae82c562a55b93895046f7}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!FindFriends@{FindFriends}}
\index{FindFriends@{FindFriends}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{FindFriends()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Find\+Friends (\begin{DoxyParamCaption}\item[{string[$\,$]}]{friends\+To\+Find }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Requests the rooms and online status for a list of friends and saves the result in Photon\+Network.\+Friends. 

Works only on Master Server to find the rooms played by a selected list of users.

The result will be stored in Photon\+Network.\+Friends when available. That list is initialized on first use of Op\+Find\+Friends (before that, it is null). To refresh the list, call Find\+Friends again (in 5 seconds or 10 or 20).

Users identify themselves by setting a unique user\+Id in the \doxyref{Photon\+Network.\+Auth\+Values}{p.}{class_photon_1_1_pun_1_1_photon_network_ad9206d09224ee87c9d8eb522efe81e78}. See remarks of Authentication\+Values for info about how this is set and used.

The list of friends must be fetched from some other source (not provided by \doxyref{Photon}{p.}{namespace_photon}).

Internal\+: The server response includes 2 arrays of info (each index matching a friend from the request)\+: \doxyref{Parameter\+Code.\+Find\+Friends\+Response\+Online\+List}{p.}{class_photon_1_1_realtime_1_1_parameter_code_a76a5bf9059c7f6ae83f70349f9378396} = bool[] of online states \doxyref{Parameter\+Code.\+Find\+Friends\+Response\+Room\+Id\+List}{p.}{class_photon_1_1_realtime_1_1_parameter_code_ae90fbf712ed42c8de99001639b9a87ce} = string[] of room names (empty string if not in a room) 


\begin{DoxyParams}{Parameters}
{\em friends\+To\+Find} & Array of friend (make sure to use unique Nick\+Name or Auth\+Values).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation could be sent (requires connection, only one request is allowed at any time). Always false in offline mode.
\end{DoxyReturn}


Definition at line \textbf{ 2182} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ac3ef7244ebae82c562a55b93895046f7_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ac3ef7244ebae82c562a55b93895046f7_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae755d87df334b523a0850c06879c3089}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!FindGameObjectsWithComponent@{FindGameObjectsWithComponent}}
\index{FindGameObjectsWithComponent@{FindGameObjectsWithComponent}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{FindGameObjectsWithComponent()}
{\footnotesize\ttfamily static Hash\+Set$<$ Game\+Object $>$ Photon.\+Pun.\+Photon\+Network.\+Find\+Game\+Objects\+With\+Component (\begin{DoxyParamCaption}\item[{Type}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds the Game\+Objects with Components of a specific type (using Find\+Objects\+Of\+Type). 


\begin{DoxyParams}{Parameters}
{\em type} & Type must be a Component\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Hash\+Set with Game\+Objects that have a specific type of Component.
\end{DoxyReturn}


Definition at line \textbf{ 2983} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aeede03b2d9c3d09b972437316adc435d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!GetCustomRoomList@{GetCustomRoomList}}
\index{GetCustomRoomList@{GetCustomRoomList}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{GetCustomRoomList()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Get\+Custom\+Room\+List (\begin{DoxyParamCaption}\item[{\textbf{ Typed\+Lobby}}]{typed\+Lobby,  }\item[{string}]{sql\+Lobby\+Filter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Fetches a custom list of games from the server, matching a (non-\/empty) SQL-\/like filter. 

Triggers On\+Room\+List\+Update callback.

Operation is only available for lobbies of type Sql\+Lobby and the filter can not be empty. It will check those conditions and fail locally, returning false. This is an async request.

Note\+: You don\textquotesingle{}t have to join a lobby to query it. Rooms need to be \char`\"{}attached\char`\"{} to a lobby, which can be done via the typed\+Lobby parameter in Create\+Room, Join\+Or\+Create\+Room, etc..

When done, On\+Room\+List\+Update gets called. 

https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby/\+::sql\+\_\+lobby\+\_\+type 
\begin{DoxyParams}{Parameters}
{\em typed\+Lobby} & The lobby to query. Has to be of type Sql\+Lobby.\\
\hline
{\em sql\+Lobby\+Filter} & The sql query statement.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation could be sent (has to be connected).
\end{DoxyReturn}


Definition at line \textbf{ 2207} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aeede03b2d9c3d09b972437316adc435d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aeede03b2d9c3d09b972437316adc435d_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a5a0dc3a5cdb4df9d0704a9bd67145cae}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!GetPhotonView@{GetPhotonView}}
\index{GetPhotonView@{GetPhotonView}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{GetPhotonView()}
{\footnotesize\ttfamily static \textbf{ Photon\+View} Photon.\+Pun.\+Photon\+Network.\+Get\+Photon\+View (\begin{DoxyParamCaption}\item[{int}]{view\+ID }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Removed aggressive find that likely had no real use case, and was expensive.

Definition at line \textbf{ 964} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a5a0dc3a5cdb4df9d0704a9bd67145cae_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac8651f3c6c9b6527030eff1c15d2b796}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!GetPing@{GetPing}}
\index{GetPing@{GetPing}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{GetPing()}
{\footnotesize\ttfamily static int Photon.\+Pun.\+Photon\+Network.\+Get\+Ping (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



The current roundtrip time to the photon server. 

\begin{DoxyReturn}{Returns}
Roundtrip time (to server and back).
\end{DoxyReturn}


Definition at line \textbf{ 1462} of file \textbf{ Photon\+Network.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ac8651f3c6c9b6527030eff1c15d2b796_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!Instantiate@{Instantiate}}
\index{Instantiate@{Instantiate}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{Instantiate()}
{\footnotesize\ttfamily static Game\+Object Photon.\+Pun.\+Photon\+Network.\+Instantiate (\begin{DoxyParamCaption}\item[{string}]{prefab\+Name,  }\item[{Vector3}]{position,  }\item[{Quaternion}]{rotation,  }\item[{byte}]{group = {\ttfamily 0},  }\item[{object[$\,$]}]{data = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 2473} of file \textbf{ Photon\+Network.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a7e68c3cae2b1b2b7495b545b246192c2}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!InstantiateRoomObject@{InstantiateRoomObject}}
\index{InstantiateRoomObject@{InstantiateRoomObject}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{InstantiateRoomObject()}
{\footnotesize\ttfamily static Game\+Object Photon.\+Pun.\+Photon\+Network.\+Instantiate\+Room\+Object (\begin{DoxyParamCaption}\item[{string}]{prefab\+Name,  }\item[{Vector3}]{position,  }\item[{Quaternion}]{rotation,  }\item[{byte}]{group = {\ttfamily 0},  }\item[{object[$\,$]}]{data = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 2491} of file \textbf{ Photon\+Network.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a7e68c3cae2b1b2b7495b545b246192c2_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_afa64fba6a5f05ede2706153c2cb4003e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!InstantiateSceneObject@{InstantiateSceneObject}}
\index{InstantiateSceneObject@{InstantiateSceneObject}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{InstantiateSceneObject()}
{\footnotesize\ttfamily static Game\+Object Photon.\+Pun.\+Photon\+Network.\+Instantiate\+Scene\+Object (\begin{DoxyParamCaption}\item[{string}]{prefab\+Name,  }\item[{Vector3}]{position,  }\item[{Quaternion}]{rotation,  }\item[{byte}]{group = {\ttfamily 0},  }\item[{object[$\,$]}]{data = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 2486} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_afa64fba6a5f05ede2706153c2cb4003e_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a27acbd663f3836dc3b5036f0854d05cd}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinLobby@{JoinLobby}}
\index{JoinLobby@{JoinLobby}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinLobby()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Lobby (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



On Master\+Server this joins the default lobby which list rooms currently in use. 

The room list is sent and refreshed by the server using \doxyref{ILobby\+Callbacks.\+On\+Room\+List\+Update}{p.}{interface_photon_1_1_realtime_1_1_i_lobby_callbacks_ae07fb2877a6af51b34db77422187dcf6}.

Per room you should check if it\textquotesingle{}s full or not before joining. \doxyref{Photon}{p.}{namespace_photon} also lists rooms that are full, unless you close and hide them (room.\+open = false and room.\+visible = false).

In best case, you make your clients join random games, as described here\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby}}

You can show your current players and room count without joining a lobby (but you must be on the master server). Use\+: Count\+Of\+Players, Count\+Of\+Players\+On\+Master, Count\+Of\+Players\+In\+Rooms and Count\+Of\+Rooms.

You can use more than one lobby to keep the room lists shorter. See \doxyref{Join\+Lobby(\+Typed\+Lobby lobby)}{p.}{class_photon_1_1_pun_1_1_photon_network_a20aecd560712580935a29ea0d14946c4}. When creating new rooms, they will be \char`\"{}attached\char`\"{} to the currently used lobby or the default lobby.

You can use Join\+Random\+Room without being in a lobby! 

Definition at line \textbf{ 2092} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_a27acbd663f3836dc3b5036f0854d05cd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a27acbd663f3836dc3b5036f0854d05cd_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a20aecd560712580935a29ea0d14946c4}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinLobby@{JoinLobby}}
\index{JoinLobby@{JoinLobby}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinLobby()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Lobby (\begin{DoxyParamCaption}\item[{\textbf{ Typed\+Lobby}}]{typed\+Lobby }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



On a Master Server you can join a lobby to get lists of available rooms. 

The room list is sent and refreshed by the server using \doxyref{ILobby\+Callbacks.\+On\+Room\+List\+Update}{p.}{interface_photon_1_1_realtime_1_1_i_lobby_callbacks_ae07fb2877a6af51b34db77422187dcf6}.

Any client can \char`\"{}make up\char`\"{} any lobby on the fly. Splitting rooms into multiple lobbies will keep each list shorter. However, having too many lists might ruin the matchmaking experience.

In best case, you create a limited number of lobbies. For example, create a lobby per game-\/mode\+: \char`\"{}koth\char`\"{} for king of the hill and \char`\"{}ffa\char`\"{} for free for all, etc.

There is no listing of lobbies at the moment.

Sql-\/typed lobbies offer a different filtering model for random matchmaking. This might be more suited for skillbased-\/games. However, you will also need to follow the conventions for naming filterable properties in sql-\/lobbies! Both is explained in the matchmaking doc linked below.

In best case, you make your clients join random games, as described here\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/realtime/current/reference/matchmaking-\/and-\/lobby}}

Per room you should check if it\textquotesingle{}s full or not before joining. \doxyref{Photon}{p.}{namespace_photon} does list rooms that are full, unless you close and hide them (room.\+open = false and room.\+visible = false).

You can show your games current players and room count without joining a lobby (but you must be on the master server). Use\+: Count\+Of\+Players, Count\+Of\+Players\+On\+Master, Count\+Of\+Players\+In\+Rooms and Count\+Of\+Rooms.

When creating new rooms, they will be \char`\"{}attached\char`\"{} to the currently used lobby or the default lobby.

You can use Join\+Random\+Room without being in a lobby! 


\begin{DoxyParams}{Parameters}
{\em typed\+Lobby} & A typed lobby to join (must have name and type).\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 2129} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a20aecd560712580935a29ea0d14946c4_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a1a8502c779302e9b39db304e4f533feb}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinOrCreateRoom@{JoinOrCreateRoom}}
\index{JoinOrCreateRoom@{JoinOrCreateRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinOrCreateRoom()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Or\+Create\+Room (\begin{DoxyParamCaption}\item[{string}]{room\+Name,  }\item[{\textbf{ Room\+Options}}]{room\+Options,  }\item[{\textbf{ Typed\+Lobby}}]{typed\+Lobby,  }\item[{string[$\,$]}]{expected\+Users = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Joins a specific room by name and creates it on demand. 

Will callback\+: On\+Joined\+Room or On\+Join\+Room\+Failed. 

Useful when players make up a room name to meet in\+: All involved clients call the same method and whoever is first, also creates the room.

When successful, the client will enter the specified room. The client which creates the room, will callback both On\+Created\+Room and On\+Joined\+Room. Clients that join an existing room will only callback On\+Joined\+Room. In all error cases, On\+Join\+Room\+Failed gets called.

Joining a room will fail, if the room is full, closed or when the user already is present in the room (checked by user\+Id).

To return to a room, use Op\+Rejoin\+Room.

This method can only be called while the client is connected to a Master Server so you should implement the callback On\+Connected\+To\+Master. Check the return value to make sure the operation will be called on the server. Note\+: There will be no callbacks if this method returned false.

If you set room properties in room\+Options, they get ignored when the room is existing already. This avoids changing the room properties by late joining players.

You can define an array of expected\+Users, to block player slots in the room for these users. The corresponding feature in \doxyref{Photon}{p.}{namespace_photon} is called \char`\"{}\+Slot Reservation\char`\"{} and can be found in the doc pages.

More about PUN matchmaking\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby}} 


\begin{DoxyParams}{Parameters}
{\em room\+Name} & Name of the room to join. Must be non null.\\
\hline
{\em room\+Options} & Options for the room, in case it does not exist yet. Else these values are ignored.\\
\hline
{\em typed\+Lobby} & Lobby you want a new room to be listed in. Ignored if the room was existing and got joined.\\
\hline
{\em expected\+Users} & Optional list of users (by User\+Id) who are expected to join this game and who you want to block a slot for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation got queued and will be sent.
\end{DoxyReturn}


Definition at line \textbf{ 1836} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a1a8502c779302e9b39db304e4f533feb_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a32be0c358e305d46ceb84e81732be0db}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinRandomOrCreateRoom@{JoinRandomOrCreateRoom}}
\index{JoinRandomOrCreateRoom@{JoinRandomOrCreateRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinRandomOrCreateRoom()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Random\+Or\+Create\+Room (\begin{DoxyParamCaption}\item[{\textbf{ Hashtable}}]{expected\+Custom\+Room\+Properties = {\ttfamily null},  }\item[{byte}]{expected\+Max\+Players = {\ttfamily 0},  }\item[{\textbf{ Matchmaking\+Mode}}]{matching\+Type = {\ttfamily MatchmakingMode.FillRoom},  }\item[{\textbf{ Typed\+Lobby}}]{typed\+Lobby = {\ttfamily null},  }\item[{string}]{sql\+Lobby\+Filter = {\ttfamily null},  }\item[{string}]{room\+Name = {\ttfamily null},  }\item[{\textbf{ Room\+Options}}]{room\+Options = {\ttfamily null},  }\item[{string[$\,$]}]{expected\+Users = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Attempts to join a room that matches the specified filter and creates a room if none found. 

This operation is a combination of filter-\/based random matchmaking with the option to create a new room, if no fitting room exists. The benefit of that is that the room creation is done by the same operation and the room can be found by the very next client, looking for similar rooms.

There are separate parameters for joining and creating a room.

This method can only be called while connected to a Master Server. This client\textquotesingle{}s State is set to Client\+State.\+Joining immediately.

Either \doxyref{IMatchmaking\+Callbacks.\+On\+Joined\+Room}{p.}{interface_photon_1_1_realtime_1_1_i_matchmaking_callbacks_a8add9e72c38d241a448f4b539acd684b} or \doxyref{IMatchmaking\+Callbacks.\+On\+Created\+Room}{p.}{interface_photon_1_1_realtime_1_1_i_matchmaking_callbacks_a3d084f0aa95b2e8f48514695af73b31d} gets called.

Should the creation on the Master Server, \doxyref{IMatchmaking\+Callbacks.\+On\+Join\+Random\+Failed}{p.}{interface_photon_1_1_realtime_1_1_i_matchmaking_callbacks_a837e8522439b89e68805a2b2c25fa824} gets called. Should the \char`\"{}join\char`\"{} on the Game Server fail, \doxyref{IMatchmaking\+Callbacks.\+On\+Join\+Room\+Failed}{p.}{interface_photon_1_1_realtime_1_1_i_matchmaking_callbacks_a55bcc9aca42ebe749a8dcb210ed145e9} gets called.

Check the return value to make sure the operation will be called on the server. Note\+: There will be no callbacks if this method returned false. 

\begin{DoxyReturn}{Returns}
If the operation will be sent (requires connection to Master Server).
\end{DoxyReturn}


Definition at line \textbf{ 1705} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a32be0c358e305d46ceb84e81732be0db_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aff48055ef5c0ffb25fad9c8a8e04f50f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinRandomRoom@{JoinRandomRoom}}
\index{JoinRandomRoom@{JoinRandomRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinRandomRoom()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Random\+Room (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Joins a random room that matches the filter. 

Will callback\+: On\+Joined\+Room or On\+Join\+Random\+Failed. 

Used for random matchmaking. You can join any room or one with specific properties defined in op\+Join\+Random\+Room\+Params.

This operation fails if no rooms are fitting or available (all full, closed, in another lobby or not visible). It may also fail when actually joining the room which was found. Rooms may close, become full or empty anytime.

This method can only be called while the client is connected to a Master Server so you should implement the callback On\+Connected\+To\+Master. Check the return value to make sure the operation will be called on the server. Note\+: There will be no callbacks if this method returned false.

More about PUN matchmaking\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby}} 

Definition at line \textbf{ 1595} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_aff48055ef5c0ffb25fad9c8a8e04f50f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aff48055ef5c0ffb25fad9c8a8e04f50f_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a67795a86a08f607bcb6053dbdb5ddef9}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinRandomRoom@{JoinRandomRoom}}
\index{JoinRandomRoom@{JoinRandomRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinRandomRoom()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Random\+Room (\begin{DoxyParamCaption}\item[{\textbf{ Hashtable}}]{expected\+Custom\+Room\+Properties,  }\item[{byte}]{expected\+Max\+Players }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Joins a random room that matches the filter. 

Will callback\+: On\+Joined\+Room or On\+Join\+Random\+Failed. 

Used for random matchmaking. You can join any room or one with specific properties defined in op\+Join\+Random\+Room\+Params.

This operation fails if no rooms are fitting or available (all full, closed, in another lobby or not visible). It may also fail when actually joining the room which was found. Rooms may close, become full or empty anytime.

This method can only be called while the client is connected to a Master Server so you should implement the callback On\+Connected\+To\+Master. Check the return value to make sure the operation will be called on the server. Note\+: There will be no callbacks if this method returned false.

More about PUN matchmaking\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby}} 


\begin{DoxyParams}{Parameters}
{\em expected\+Custom\+Room\+Properties} & Filters for rooms that match these custom properties (string keys and values). To ignore, pass null.\\
\hline
{\em expected\+Max\+Players} & Filters for a particular maxplayer setting. Use 0 to accept any max\+Player value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation got queued and will be sent.
\end{DoxyReturn}


Definition at line \textbf{ 1620} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a67795a86a08f607bcb6053dbdb5ddef9_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a875d4e8ae4a362db598eac33b5fb5313}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinRandomRoom@{JoinRandomRoom}}
\index{JoinRandomRoom@{JoinRandomRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinRandomRoom()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Random\+Room (\begin{DoxyParamCaption}\item[{\textbf{ Hashtable}}]{expected\+Custom\+Room\+Properties,  }\item[{byte}]{expected\+Max\+Players,  }\item[{\textbf{ Matchmaking\+Mode}}]{matching\+Type,  }\item[{\textbf{ Typed\+Lobby}}]{typed\+Lobby,  }\item[{string}]{sql\+Lobby\+Filter,  }\item[{string[$\,$]}]{expected\+Users = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Joins a random room that matches the filter. 

Will callback\+: On\+Joined\+Room or On\+Join\+Random\+Failed. 

Used for random matchmaking. You can join any room or one with specific properties defined in op\+Join\+Random\+Room\+Params.

This operation fails if no rooms are fitting or available (all full, closed, in another lobby or not visible). It may also fail when actually joining the room which was found. Rooms may close, become full or empty anytime.

This method can only be called while the client is connected to a Master Server so you should implement the callback On\+Connected\+To\+Master. Check the return value to make sure the operation will be called on the server. Note\+: There will be no callbacks if this method returned false.

More about PUN matchmaking\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby}} 


\begin{DoxyParams}{Parameters}
{\em expected\+Custom\+Room\+Properties} & Filters for rooms that match these custom properties (string keys and values). To ignore, pass null.\\
\hline
{\em expected\+Max\+Players} & Filters for a particular maxplayer setting. Use 0 to accept any max\+Player value.\\
\hline
{\em matching\+Type} & Selects one of the available matchmaking algorithms. See Matchmaking\+Mode enum for options.\\
\hline
{\em typed\+Lobby} & The lobby in which you want to lookup a room. Pass null, to use the default lobby. This does not join that lobby and neither sets the lobby property.\\
\hline
{\em sql\+Lobby\+Filter} & A filter-\/string for SQL-\/typed lobbies.\\
\hline
{\em expected\+Users} & Optional list of users (by User\+Id) who are expected to join this game and who you want to block a slot for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation got queued and will be sent.
\end{DoxyReturn}


Definition at line \textbf{ 1649} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a875d4e8ae4a362db598eac33b5fb5313_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae4640a50e5a883807370aaa4a4d6102d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!JoinRoom@{JoinRoom}}
\index{JoinRoom@{JoinRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{JoinRoom()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Join\+Room (\begin{DoxyParamCaption}\item[{string}]{room\+Name,  }\item[{string[$\,$]}]{expected\+Users = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Joins a room by name. 

Will callback\+: On\+Joined\+Room or On\+Join\+Room\+Failed. 

Useful when using lobbies or when players follow friends or invite each other.

When successful, the client will enter the specified room and callback via On\+Joined\+Room. In all error cases, On\+Join\+Room\+Failed gets called.

Joining a room will fail if the room is full, closed, not existing or when the user already is present in the room (checked by user\+Id).

To return to a room, use Op\+Rejoin\+Room. When players invite each other and it\textquotesingle{}s unclear who\textquotesingle{}s first to respond, use Op\+Join\+Or\+Create\+Room instead.

This method can only be called while the client is connected to a Master Server so you should implement the callback On\+Connected\+To\+Master. Check the return value to make sure the operation will be called on the server. Note\+: There will be no callbacks if this method returned false.

More about PUN matchmaking\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/lobby-\/and-\/matchmaking/matchmaking-\/and-\/lobby}} 

On\+Join\+Room\+Failed On\+Joined\+Room 
\begin{DoxyParams}{Parameters}
{\em room\+Name} & Unique name of the room to join.\\
\hline
{\em expected\+Users} & Optional list of users (by User\+Id) who are expected to join this game and who you want to block a slot for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation got queued and will be sent.
\end{DoxyReturn}


Definition at line \textbf{ 1901} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ae4640a50e5a883807370aaa4a4d6102d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ae4640a50e5a883807370aaa4a4d6102d_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a2fa56a022fa01dbbe46475d7d77f5e59}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LeaveLobby@{LeaveLobby}}
\index{LeaveLobby@{LeaveLobby}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LeaveLobby()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Leave\+Lobby (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Leave a lobby to stop getting updates about available rooms. 

This does not reset Photon\+Network.\+lobby! This allows you to join this particular lobby later easily.

The values Count\+Of\+Players, Count\+Of\+Players\+On\+Master, Count\+Of\+Players\+In\+Rooms and Count\+Of\+Rooms are received even without being in a lobby.

You can use Join\+Random\+Room without being in a lobby. 

Definition at line \textbf{ 2149} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a2fa56a022fa01dbbe46475d7d77f5e59_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a2fa56a022fa01dbbe46475d7d77f5e59_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a6efe3af5ec21c4ed14b1d4d95eef965f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LeaveRoom@{LeaveRoom}}
\index{LeaveRoom@{LeaveRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LeaveRoom()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Leave\+Room (\begin{DoxyParamCaption}\item[{bool}]{become\+Inactive = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Leave the current room and return to the Master Server where you can join or create rooms (see remarks). 

This will clean up all (network) Game\+Objects with a \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}, unless you changed auto\+Clean\+Up to false. Returns to the Master Server.

In Offline\+Mode, the local \char`\"{}fake\char`\"{} room gets cleaned up and On\+Left\+Room gets called immediately.

In a room with player\+TTL \texorpdfstring{$<$}{<} 0, Leave\+Room just turns a client inactive. The player stays in the room\textquotesingle{}s player list and can return later on. Setting become\+Inactive to false deliberately, means to \char`\"{}abandon\char`\"{} the room, despite the player\+TTL allowing you to come back.

In a room with player\+TTL == 0, become inactive has no effect (clients are removed from the room right away). 


\begin{DoxyParams}{Parameters}
{\em become\+Inactive} & If this client becomes inactive in a room with player\+TTL \texorpdfstring{$<$}{<} 0. Defaults to true.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 2026} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a6efe3af5ec21c4ed14b1d4d95eef965f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a6efe3af5ec21c4ed14b1d4d95eef965f_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a9aa7d7a2389b180e95c81921076ac056}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LoadLevel@{LoadLevel}}
\index{LoadLevel@{LoadLevel}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LoadLevel()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Load\+Level (\begin{DoxyParamCaption}\item[{int}]{level\+Number }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



This method wraps loading a level asynchronously and pausing network messages during the process. 

While loading levels in a networked game, it makes sense to not dispatch messages received by other players. Load\+Level takes care of that by setting \doxyref{Photon\+Network.\+Is\+Message\+Queue\+Running}{p.}{class_photon_1_1_pun_1_1_photon_network_a0ac7974d889dbb6498a161e62be6e4ff} = false until the scene loaded.

To sync the loaded level in a room, set \doxyref{Photon\+Network.\+Automatically\+Sync\+Scene}{p.}{class_photon_1_1_pun_1_1_photon_network_a2440ba4650d0f1dbb3d3091bb44758d4} to true. The Master Client of a room will then sync the loaded level with every other player in the room. Note that this works only for a single active scene and that reloading the scene is not supported. The Master Client will actually reload a scene but other clients won\textquotesingle{}t.

You should make sure you don\textquotesingle{}t fire RPCs before you load another scene (which doesn\textquotesingle{}t contain the same Game\+Objects and Photon\+Views).

Load\+Level uses Scene\+Manager.\+Load\+Scene\+Async().

Check the progress of the Level\+Loading using \doxyref{Photon\+Network.\+Level\+Loading\+Progress}{p.}{class_photon_1_1_pun_1_1_photon_network_a12a1a136d0ad40dad66af5373a21a222}.

Calling Load\+Level before the previous scene finished loading is not recommended. If Automatically\+Sync\+Scene is enabled, PUN cancels the previous load (and prevent that from becoming the active scene). If Automatically\+Sync\+Scene is off, the previous scene loading can finish. In both cases, a new scene is loaded locally. 


\begin{DoxyParams}{Parameters}
{\em level\+Number} & Build-\/index number of the level to load. When using level numbers, make sure they are identical on all clients. \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 3056} of file \textbf{ Photon\+Network.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a9aa7d7a2389b180e95c81921076ac056_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aae0580953bb12206178d0e7f438a01ed}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LoadLevel@{LoadLevel}}
\index{LoadLevel@{LoadLevel}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LoadLevel()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Load\+Level (\begin{DoxyParamCaption}\item[{string}]{level\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



This method wraps loading a level asynchronously and pausing network messages during the process. 

While loading levels in a networked game, it makes sense to not dispatch messages received by other players. Load\+Level takes care of that by setting \doxyref{Photon\+Network.\+Is\+Message\+Queue\+Running}{p.}{class_photon_1_1_pun_1_1_photon_network_a0ac7974d889dbb6498a161e62be6e4ff} = false until the scene loaded.

To sync the loaded level in a room, set \doxyref{Photon\+Network.\+Automatically\+Sync\+Scene}{p.}{class_photon_1_1_pun_1_1_photon_network_a2440ba4650d0f1dbb3d3091bb44758d4} to true. The Master Client of a room will then sync the loaded level with every other player in the room. Note that this works only for a single active scene and that reloading the scene is not supported. The Master Client will actually reload a scene but other clients won\textquotesingle{}t.

You should make sure you don\textquotesingle{}t fire RPCs before you load another scene (which doesn\textquotesingle{}t contain the same Game\+Objects and Photon\+Views).

Load\+Level uses Scene\+Manager.\+Load\+Scene\+Async().

Check the progress of the Level\+Loading using \doxyref{Photon\+Network.\+Level\+Loading\+Progress}{p.}{class_photon_1_1_pun_1_1_photon_network_a12a1a136d0ad40dad66af5373a21a222}.

Calling Load\+Level before the previous scene finished loading is not recommended. If Automatically\+Sync\+Scene is enabled, PUN cancels the previous load (and prevent that from becoming the active scene). If Automatically\+Sync\+Scene is off, the previous scene loading can finish. In both cases, a new scene is loaded locally. 


\begin{DoxyParams}{Parameters}
{\em level\+Name} & Name of the level to load. Make sure it\textquotesingle{}s available to all clients in the same room. \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 3098} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3f82ce93e20527fd56d98e1c06717ae8}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LoadOrCreateSettings@{LoadOrCreateSettings}}
\index{LoadOrCreateSettings@{LoadOrCreateSettings}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LoadOrCreateSettings()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Load\+Or\+Create\+Settings (\begin{DoxyParamCaption}\item[{bool}]{reload = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 3171} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a5fc0e5e4b489351e98c066601bc94936}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LocalCleanPhotonView@{LocalCleanPhotonView}}
\index{LocalCleanPhotonView@{LocalCleanPhotonView}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LocalCleanPhotonView()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Local\+Clean\+Photon\+View (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 958} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a9affbaea306927af8c46eb965ebe8051}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!NetworkStatisticsReset@{NetworkStatisticsReset}}
\index{NetworkStatisticsReset@{NetworkStatisticsReset}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{NetworkStatisticsReset()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Network\+Statistics\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Resets the traffic stats and re-\/enables them. 



Definition at line \textbf{ 1421} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a0f9f4fff21c90ab767b95ac2fbad422b}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!NetworkStatisticsToString@{NetworkStatisticsToString}}
\index{NetworkStatisticsToString@{NetworkStatisticsToString}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{NetworkStatisticsToString()}
{\footnotesize\ttfamily static string Photon.\+Pun.\+Photon\+Network.\+Network\+Statistics\+To\+String (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Only available when Network\+Statistics\+Enabled was used to gather some stats. 

\begin{DoxyReturn}{Returns}
A string with vital networking statistics.
\end{DoxyReturn}


Definition at line \textbf{ 1431} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a92ebf88db80533a34e0dd73ffb6b1086}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!OpCleanActorRpcBuffer@{OpCleanActorRpcBuffer}}
\index{OpCleanActorRpcBuffer@{OpCleanActorRpcBuffer}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{OpCleanActorRpcBuffer()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Op\+Clean\+Actor\+Rpc\+Buffer (\begin{DoxyParamCaption}\item[{int}]{actor\+Number }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Removes the RPCs of someone else (to be used as master). 

This won\textquotesingle{}t clean any local caches. It just tells the server to forget a player\textquotesingle{}s RPCs and instantiates. 


\begin{DoxyParams}{Parameters}
{\em actor\+Number} & \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1041} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a92ebf88db80533a34e0dd73ffb6b1086_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a9aad4dca8370d71a36a72d57a4fb3240}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!OpCleanRpcBuffer@{OpCleanRpcBuffer}}
\index{OpCleanRpcBuffer@{OpCleanRpcBuffer}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{OpCleanRpcBuffer()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Op\+Clean\+Rpc\+Buffer (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Cleans server RPCs for \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} (without any further checks).



Definition at line \textbf{ 1091} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a9aad4dca8370d71a36a72d57a4fb3240_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a499d471cc173a8603d8f3af988eecbca}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!OpRemoveCompleteCache@{OpRemoveCompleteCache}}
\index{OpRemoveCompleteCache@{OpRemoveCompleteCache}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{OpRemoveCompleteCache()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Op\+Remove\+Complete\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 1058} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a499d471cc173a8603d8f3af988eecbca_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a1d6b12821927bafd0b26033232400bbd}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!OpRemoveCompleteCacheOfPlayer@{OpRemoveCompleteCacheOfPlayer}}
\index{OpRemoveCompleteCacheOfPlayer@{OpRemoveCompleteCacheOfPlayer}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{OpRemoveCompleteCacheOfPlayer()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Op\+Remove\+Complete\+Cache\+Of\+Player (\begin{DoxyParamCaption}\item[{int}]{actor\+Number }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Instead removing RPCs or Instantiates, this removed everything cached by the actor. 


\begin{DoxyParams}{Parameters}
{\em actor\+Number} & \\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1051} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a9445d7b33be290e7a668284bad051e79}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RaiseEvent@{RaiseEvent}}
\index{RaiseEvent@{RaiseEvent}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RaiseEvent()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Raise\+Event (\begin{DoxyParamCaption}\item[{byte}]{event\+Code,  }\item[{object}]{event\+Content,  }\item[{\textbf{ Raise\+Event\+Options}}]{raise\+Event\+Options,  }\item[{Send\+Options}]{send\+Options }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Sends fully customizable events in a room. 

Events consist of at least an Event\+Code (0..199) and can have content. 

To receive events, implement IOn\+Event\+Callback in any class and register it via \doxyref{Photon\+Network.\+Add\+Callback\+Target}{p.}{class_photon_1_1_pun_1_1_photon_network_ab6df1ed60be8a3f494683b8faa28ee4a}. See \doxyref{IOn\+Event\+Callback.\+On\+Event}{p.}{interface_photon_1_1_realtime_1_1_i_on_event_callback_a0e69d8b1154c5438d5e5a224dd869e45}.

The event\+Content is optional. If set, event\+Content must be a \char`\"{}serializable type\char`\"{}, something that the client can turn into a byte[] basically. Most basic types and arrays of them are supported, including Unity\textquotesingle{}s Vector2, Vector3, Quaternion. Transforms are not supported.

You can turn a class into a \char`\"{}serializable type\char`\"{} by following the example in \doxyref{Custom\+Types.\+cs}{p.}{_custom_types_8cs}.

The Raise\+Event\+Options have some (less intuitive) combination rules\+: If you set target\+Actors (an array of Player.\+ID values), the receivers parameter gets ignored. When using event caching, the target\+Actors, receivers and interest\+Group can\textquotesingle{}t be used. Buffered events go to all. When using caching\+Option remove\+From\+Room\+Cache, the event\+Code and content are actually not sent but used as filter. 


\begin{DoxyParams}{Parameters}
{\em event\+Code} & A byte identifying the type of event. You might want to use a code per action or to signal which content can be expected. Allowed\+: 0..199.\\
\hline
{\em event\+Content} & Some serializable object like string, byte, integer, float (etc) and arrays of those. Hashtables with byte keys are good to send variable content.\\
\hline
{\em raise\+Event\+Options} & Allows more complex usage of events. If null, \doxyref{Raise\+Event\+Options.\+Default}{p.}{class_photon_1_1_realtime_1_1_raise_event_options_a46600448e9a8a9576172d1d761b0652d} will be used (which is fine).\\
\hline
{\em send\+Options} & Send options for reliable, encryption etc..\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
False if event could not be sent.
\end{DoxyReturn}


Definition at line \textbf{ 2306} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a9445d7b33be290e7a668284bad051e79_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a9445d7b33be290e7a668284bad051e79_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_afd132f2621f17054934ed5f1296997ed}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!Reconnect@{Reconnect}}
\index{Reconnect@{Reconnect}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{Reconnect()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Reconnect (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Can be used to reconnect to the master server after a disconnect. 

After losing connection, you can use this to connect a client to the region Master Server again. Cache the room name you\textquotesingle{}re in and use Rejoin\+Room(roomname) to return to a game. Common use case\+: Press the Lock Button on a i\+OS device and you get disconnected immediately. 

Definition at line \textbf{ 1387} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_afd132f2621f17054934ed5f1296997ed_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_afd132f2621f17054934ed5f1296997ed_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae42cf1f2e37a5c3631e2537b35d511bc}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ReconnectAndRejoin@{ReconnectAndRejoin}}
\index{ReconnectAndRejoin@{ReconnectAndRejoin}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ReconnectAndRejoin()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Reconnect\+And\+Rejoin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



When the client lost connection during gameplay, this method attempts to reconnect and rejoin the room. 

This method re-\/connects directly to the game server which was hosting the room PUN was in before. If the room was shut down in the meantime, PUN will call On\+Join\+Room\+Failed and return this client to the Master Server.

Check the return value, if this client will attempt a reconnect and rejoin (if the conditions are met). If Reconnect\+And\+Rejoin returns false, you can still attempt a Reconnect and Rejoin.

Similar to \doxyref{Photon\+Network.\+Rejoin\+Room}{p.}{class_photon_1_1_pun_1_1_photon_network_af4b1a8a87b39134b946ae85128e9d5e1}, this requires you to use unique IDs per player (the User\+ID).

Rejoining room will not send any player properties. Instead client will receive up-\/to-\/date ones from server. If you want to set new player properties, do it once rejoined. 

\begin{DoxyReturn}{Returns}
False, if there is no known room or game server to return to. Then, this client does not attempt the Reconnect\+And\+Rejoin.
\end{DoxyReturn}


Definition at line \textbf{ 1989} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ae42cf1f2e37a5c3631e2537b35d511bc_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ae42cf1f2e37a5c3631e2537b35d511bc_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aab7b6f3722d255f61026370a492b17c9}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RegisterPhotonView@{RegisterPhotonView}}
\index{RegisterPhotonView@{RegisterPhotonView}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RegisterPhotonView()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Register\+Photon\+View (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{net\+View }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 991} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_af4b1a8a87b39134b946ae85128e9d5e1}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RejoinRoom@{RejoinRoom}}
\index{RejoinRoom@{RejoinRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RejoinRoom()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Rejoin\+Room (\begin{DoxyParamCaption}\item[{string}]{room\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Rejoins a room by room\+Name (using the user\+ID internally to return). 

Will callback\+: On\+Joined\+Room or On\+Join\+Room\+Failed. 

After losing connection, you might be able to return to a room and continue playing, if the client is reconnecting fast enough. Use \doxyref{Reconnect()}{p.}{class_photon_1_1_pun_1_1_photon_network_afd132f2621f17054934ed5f1296997ed} and this method. Cache the room name you\textquotesingle{}re in and use Rejoin\+Room(roomname) to return to a game.

Note\+: To be able to Rejoin any room, you need to use User\+IDs! You also need to set \doxyref{Room\+Options.\+Player\+Ttl}{p.}{class_photon_1_1_realtime_1_1_room_options_a34ddc1efdd5dc169f2f468b0cdaa3941}.

{\bfseries{Important\+: \doxyref{Instantiate()}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0} and use of RPCs is not yet supported.}} The ownership rules of Photon\+Views prevent a seamless return to a game, if you use Photon\+Views. Use Custom Properties and Raise\+Event with event caching instead.

Common use case\+: Press the Lock Button on a i\+OS device and you get disconnected immediately.

Rejoining room will not send any player properties. Instead client will receive up-\/to-\/date ones from server. If you want to set new player properties, do it once rejoined. 

Definition at line \textbf{ 1953} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_af4b1a8a87b39134b946ae85128e9d5e1_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_af4b1a8a87b39134b946ae85128e9d5e1_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a945d91d15518d2a5f64e774016e71e54}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RemoveBufferedRPCs@{RemoveBufferedRPCs}}
\index{RemoveBufferedRPCs@{RemoveBufferedRPCs}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RemoveBufferedRPCs()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Remove\+Buffered\+RPCs (\begin{DoxyParamCaption}\item[{int}]{view\+Id = {\ttfamily 0},  }\item[{string}]{method\+Name = {\ttfamily null},  }\item[{int[$\,$]}]{callers\+Actor\+Numbers = {\ttfamily null} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Clear buffered RPCs based on filter parameters. 


\begin{DoxyParams}{Parameters}
{\em view\+Id} & The view\+ID of the \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} where the RPC has been called on. We actually need its View\+ID. If 0 (default) is provided, all Photon\+Views/\+View\+IDs are considered.\\
\hline
{\em method\+Name} & The RPC method name, if possible we will use its hash shortcut for efficiency. If none (null or empty string) is provided all RPC method names are considered.\\
\hline
{\em callers\+Actor\+Numbers} & The actor numbers of the players who called/buffered the RPC. For example if two players buffered the same RPC you can clear the buffered RPC of one and keep the other. If none (null or empty array) is provided all senders are considered.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the operation could be sent to the server.
\end{DoxyReturn}


Definition at line \textbf{ 1124} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ab9dccde85539981763815278d55f5e27}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RemoveCallbackTarget@{RemoveCallbackTarget}}
\index{RemoveCallbackTarget@{RemoveCallbackTarget}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RemoveCallbackTarget()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Remove\+Callback\+Target (\begin{DoxyParamCaption}\item[{object}]{target }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Removes the target object from callbacks for its implemented callback-\/interfaces. 

The covered callback interfaces are\+: IConnection\+Callbacks, IMatchmaking\+Callbacks, ILobby\+Callbacks, IIn\+Room\+Callbacks, IOn\+Event\+Callback and IWeb\+Rpc\+Callback.

See\+: {\texttt{ .Net Callbacks}} 


\begin{DoxyParams}{Parameters}
{\em target} & The object that unregisters from getting callbacks.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 135} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ab9dccde85539981763815278d55f5e27_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ab9dccde85539981763815278d55f5e27_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a61a28654d39169773fbb11bcca8f2da3}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RemovePlayerCustomProperties@{RemovePlayerCustomProperties}}
\index{RemovePlayerCustomProperties@{RemovePlayerCustomProperties}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RemovePlayerCustomProperties()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Remove\+Player\+Custom\+Properties (\begin{DoxyParamCaption}\item[{string[$\,$]}]{custom\+Properties\+To\+Delete }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Locally removes Custom Properties of \char`\"{}this\char`\"{} player. 

Important\+: This does not synchronize the change! Useful when you switch rooms. 

Use this method with care. It can create inconsistencies of state between players! This only changes the player.\+custom\+Properties locally. This can be useful to clear your Custom Properties between games (let\textquotesingle{}s say they store which turn you made, kills, etc).

\doxyref{Set\+Player\+Custom\+Properties()}{p.}{class_photon_1_1_pun_1_1_photon_network_a46855eb211f07258cae4afbf26467f89} syncs and can be used to set values to null while in a room. That can be considered \char`\"{}removed\char`\"{} while in a room.

If custom\+Properties\+To\+Delete is null or has 0 entries, all Custom Properties are deleted (replaced with a new Hashtable). If you specify keys to remove, those will be removed from the Hashtable but other keys are unaffected. 


\begin{DoxyParams}{Parameters}
{\em custom\+Properties\+To\+Delete} & List of Custom Property keys to remove. See remarks.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 2262} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a157da0bb230e0ea5b209a462d81b115f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RemoveRPCs@{RemoveRPCs}}
\index{RemoveRPCs@{RemoveRPCs}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RemoveRPCs()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Remove\+RPCs (\begin{DoxyParamCaption}\item[{\textbf{ Photon\+View}}]{target\+Photon\+View }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Remove all buffered RPCs from server that were sent via target\+Photon\+View. 

The Master Client and the owner of the target\+Photon\+View may call this. 

This method requires either\+:
\begin{DoxyItemize}
\item The target\+Photon\+View is owned by this client (Instantiated by it).
\item This client is the Master Client (can remove any \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}\textquotesingle{}s RPCs). 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em target\+Photon\+View} & RPCs buffered for this \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} get removed from server buffer.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 2905} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a157da0bb230e0ea5b209a462d81b115f_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a15db18b5389663d86c17117eba98714d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RemoveRPCs@{RemoveRPCs}}
\index{RemoveRPCs@{RemoveRPCs}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RemoveRPCs()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Remove\+RPCs (\begin{DoxyParamCaption}\item[{\textbf{ Player}}]{target\+Player }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Remove all buffered RPCs from server that were sent by target\+Player. 

Can only be called on local player (for \char`\"{}self\char`\"{}) or Master Client (for anyone). 

This method requires either\+:
\begin{DoxyItemize}
\item This is the target\+Player\textquotesingle{}s client.
\item This client is the Master Client (can remove any Player\textquotesingle{}s RPCs).
\end{DoxyItemize}

If the target\+Player calls RPCs at the same time that this is called, network lag will determine if those get buffered or cleared like the rest. 


\begin{DoxyParams}{Parameters}
{\em target\+Player} & This player\textquotesingle{}s buffered RPCs get removed from server buffer.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 2880} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a15db18b5389663d86c17117eba98714d_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aae076cc19e6b371c3e0dd5caf651cee3}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RemoveRPCsInGroup@{RemoveRPCsInGroup}}
\index{RemoveRPCsInGroup@{RemoveRPCsInGroup}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RemoveRPCsInGroup()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Remove\+RPCs\+In\+Group (\begin{DoxyParamCaption}\item[{int}]{group }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Remove all buffered RPCs from server that were sent in the target\+Group, if this is the Master Client or if this controls the individual \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}. 

This method requires either\+:
\begin{DoxyItemize}
\item This client is the Master Client (can remove any RPCs per group).
\item Any other client\+: each \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} is checked if it is under this client\textquotesingle{}s control. Only those RPCs are removed. 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em group} & Interest group that gets all RPCs removed.\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1106} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aae076cc19e6b371c3e0dd5caf651cee3_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac7905c06b48747ec4b86d0b75107ddc4}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SendAllOutgoingCommands@{SendAllOutgoingCommands}}
\index{SendAllOutgoingCommands@{SendAllOutgoingCommands}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SendAllOutgoingCommands()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Send\+All\+Outgoing\+Commands (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Can be used to immediately send the RPCs and Instantiates just called, so they are on their way to the other players. 

This could be useful if you do a RPC to load a level and then load it yourself. While loading, no RPCs are sent to others, so this would delay the \char`\"{}load\char`\"{} RPC. You can send the RPC to \char`\"{}others\char`\"{}, use this method, disable the message queue (by Is\+Message\+Queue\+Running) and then load. 

Definition at line \textbf{ 1486} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aa941f29879694fd0a54f1ae58f8e394a}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetInterestGroups@{SetInterestGroups}}
\index{SetInterestGroups@{SetInterestGroups}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetInterestGroups()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Set\+Interest\+Groups (\begin{DoxyParamCaption}\item[{byte}]{group,  }\item[{bool}]{enabled }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Enable/disable receiving events from a given Interest Group. 

A client can tell the server which Interest Groups it\textquotesingle{}s interested in. The server will only forward events for those Interest Groups to that client (saving bandwidth and performance).

See\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/gameplay/interestgroups}}

See\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/demos-\/and-\/tutorials/package-\/demos/culling-\/demo}} 


\begin{DoxyParams}{Parameters}
{\em group} & The interest group to affect.\\
\hline
{\em enabled} & Sets if receiving from group to enabled (or not).\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 3011} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_aa941f29879694fd0a54f1ae58f8e394a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{class_photon_1_1_pun_1_1_photon_network_aa941f29879694fd0a54f1ae58f8e394a_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae25c8c7c59cc3a949c87f65e7fb17137}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetInterestGroups@{SetInterestGroups}}
\index{SetInterestGroups@{SetInterestGroups}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetInterestGroups()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Set\+Interest\+Groups (\begin{DoxyParamCaption}\item[{byte[$\,$]}]{disable\+Groups,  }\item[{byte[$\,$]}]{enable\+Groups }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Enable/disable receiving on given Interest Groups (applied to Photon\+Views). 

A client can tell the server which Interest Groups it\textquotesingle{}s interested in. The server will only forward events for those Interest Groups to that client (saving bandwidth and performance).

See\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/gameplay/interestgroups}}

See\+: {\texttt{ https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/demos-\/and-\/tutorials/package-\/demos/culling-\/demo}} 


\begin{DoxyParams}{Parameters}
{\em disable\+Groups} & The interest groups to disable (or null).\\
\hline
{\em enable\+Groups} & The interest groups to enable (or null).\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1348} of file \textbf{ Photon\+Network\+Part.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_ae25c8c7c59cc3a949c87f65e7fb17137_cgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aa96c0ef07eda12df14185fd5d6aa0dda}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetLevelPrefix@{SetLevelPrefix}}
\index{SetLevelPrefix@{SetLevelPrefix}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetLevelPrefix()}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Set\+Level\+Prefix (\begin{DoxyParamCaption}\item[{byte}]{prefix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Sets level prefix for Photon\+Views instantiated later on. 

Don\textquotesingle{}t set it if you need only one! 

Important\+: If you don\textquotesingle{}t use multiple level prefixes, simply don\textquotesingle{}t set this value. The default value is optimized out of the traffic.

This won\textquotesingle{}t affect existing Photon\+Views (they can\textquotesingle{}t be changed yet for existing Photon\+Views).

Messages sent with a different level prefix will be received but not executed. This affects RPCs, Instantiates and synchronization.

Be aware that PUN never resets this value, you\textquotesingle{}ll have to do so yourself. 


\begin{DoxyParams}{Parameters}
{\em prefix} & Max value is short.\+Max\+Value = 255\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1172} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a79ead2d883073a16d4ae87d973499960}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetMasterClient@{SetMasterClient}}
\index{SetMasterClient@{SetMasterClient}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetMasterClient()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Set\+Master\+Client (\begin{DoxyParamCaption}\item[{\textbf{ Player}}]{master\+Client\+Player }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Asks the server to assign another player as Master Client of your current room. 

RPCs and Raise\+Event have the option to send messages only to the Master Client of a room. Set\+Master\+Client affects which client gets those messages.

This method calls an operation on the server to set a new Master Client, which takes a roundtrip. In case of success, this client and the others get the new Master Client from the server.

Set\+Master\+Client tells the server which current Master Client should be replaced with the new one. It will fail, if anything switches the Master Client moments earlier. There is no callback for this error. All clients should get the new Master Client assigned by the server anyways.

See also\+: \doxyref{Photon\+Network.\+Master\+Client}{p.}{class_photon_1_1_pun_1_1_photon_network_a7ab30903c626b476fb4500ba897da7d4}

On v3 servers\+: The \doxyref{Receiver\+Group.\+Master\+Client}{p.}{namespace_photon_1_1_realtime_a32e1cc9d538d60db8e5fb79b7a4e2e40ad0209f4a40060d6e7c37d29979d8f444} (usable in RPCs) is not affected by this (still points to lowest player.\+ID in room). Avoid using this enum value (and send to a specific player instead).

If the current Master Client leaves, PUN will detect a new one by \char`\"{}lowest player ID\char`\"{}. Implement On\+Master\+Client\+Switched to get a callback in this case. The PUN-\/selected Master Client might assign a new one.

Make sure you don\textquotesingle{}t create an endless loop of Master-\/assigning! When selecting a custom Master Client, all clients should point to the same player, no matter who actually assigns this player.

Locally the Master Client is immediately switched, while remote clients get an event. This means the game is tempoarily without Master Client like when a current Master Client leaves.

When switching the Master Client manually, keep in mind that this user might leave and not do it\textquotesingle{}s work, just like any Master Client.


\begin{DoxyParams}{Parameters}
{\em master\+Client\+Player} & The player to become the next Master Client.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
False when this operation couldn\textquotesingle{}t be done. Must be in a room (not in Offline\+Mode).
\end{DoxyReturn}


Definition at line \textbf{ 1566} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a79ead2d883073a16d4ae87d973499960_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a79ead2d883073a16d4ae87d973499960_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a46855eb211f07258cae4afbf26467f89}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetPlayerCustomProperties@{SetPlayerCustomProperties}}
\index{SetPlayerCustomProperties@{SetPlayerCustomProperties}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetPlayerCustomProperties()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Set\+Player\+Custom\+Properties (\begin{DoxyParamCaption}\item[{\textbf{ Hashtable}}]{custom\+Properties }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Sets this (local) player\textquotesingle{}s properties and synchronizes them to the other players (don\textquotesingle{}t modify them directly). 

While in a room, your properties are synced with the other players. Create\+Room, Join\+Room and Join\+Random\+Room will all apply your player\textquotesingle{}s custom properties when you enter the room. The whole Hashtable will get sent. Minimize the traffic by setting only updated key/values.

If the Hashtable is null, the custom properties will be cleared. Custom properties are never cleared automatically, so they carry over to the next room, if you don\textquotesingle{}t change them.

Don\textquotesingle{}t set properties by modifying Photon\+Network.\+player.\+custom\+Properties! 


\begin{DoxyParams}{Parameters}
{\em custom\+Properties} & Only string-\/typed keys will be used from this hashtable. If null, custom properties are all deleted.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
False if custom\+Properties is empty or have zero string keys. True in offline mode. True if not in a room and this is the local player (use this to cache properties to be sent when joining a room). Otherwise, returns if this operation could be sent to the server. 
\end{DoxyReturn}


Definition at line \textbf{ 2233} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a46855eb211f07258cae4afbf26467f89_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_a46855eb211f07258cae4afbf26467f89_icgraph}
\end{center}
\end{figure}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3e7bea13a0673f4fb5d759e483a49ef2}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetPlayerCustomProperties@{SetPlayerCustomProperties}}
\index{SetPlayerCustomProperties@{SetPlayerCustomProperties}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetPlayerCustomProperties()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Set\+Player\+Custom\+Properties (\begin{DoxyParamCaption}\item[{\textbf{ System.\+Collections.\+Hashtable}}]{hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 35} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a69cd71b5679fd7990c8c090b067200f2}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetSendingEnabled@{SetSendingEnabled}}
\index{SetSendingEnabled@{SetSendingEnabled}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetSendingEnabled()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Set\+Sending\+Enabled (\begin{DoxyParamCaption}\item[{byte}]{group,  }\item[{bool}]{enabled }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Enable/disable sending on given group (applied to Photon\+Views)

This does not interact with the \doxyref{Photon}{p.}{namespace_photon} server-\/side. It\textquotesingle{}s just a client-\/side setting to suppress updates, should they be sent to one of the blocked groups.

This setting is not particularly useful, as it means that updates literally never reach the server or anyone else. Use with care. 


\begin{DoxyParams}{Parameters}
{\em group} & The interest group to affect.\\
\hline
{\em enabled} & Sets if sending to group is enabled (or not).\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1423} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a4a9b4071611f416c6d12073d5c52fc44}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SetSendingEnabled@{SetSendingEnabled}}
\index{SetSendingEnabled@{SetSendingEnabled}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SetSendingEnabled()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Photon.\+Pun.\+Photon\+Network.\+Set\+Sending\+Enabled (\begin{DoxyParamCaption}\item[{byte[$\,$]}]{disable\+Groups,  }\item[{byte[$\,$]}]{enable\+Groups }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Enable/disable sending on given groups (applied to Photon\+Views)

This does not interact with the \doxyref{Photon}{p.}{namespace_photon} server-\/side. It\textquotesingle{}s just a client-\/side setting to suppress updates, should they be sent to one of the blocked groups.

This setting is not particularly useful, as it means that updates literally never reach the server or anyone else. Use with care. 
\begin{DoxyParams}{Parameters}
{\em enable\+Groups} & The interest groups to enable sending on (or null).\\
\hline
{\em disable\+Groups} & The interest groups to disable sending on (or null).\\
\hline
\end{DoxyParams}


Definition at line \textbf{ 1448} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aec48642992944ee0a7ea14bd4c51a8a1}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!WebRpc@{WebRpc}}
\index{WebRpc@{WebRpc}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{WebRpc()}
{\footnotesize\ttfamily static bool Photon.\+Pun.\+Photon\+Network.\+Web\+Rpc (\begin{DoxyParamCaption}\item[{string}]{name,  }\item[{object}]{parameters,  }\item[{bool}]{send\+Auth\+Cookie = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



This operation makes \doxyref{Photon}{p.}{namespace_photon} call your custom web-\/service by name (path) with the given parameters. 

This is a server-\/side feature which must be setup in the \doxyref{Photon}{p.}{namespace_photon} Cloud Dashboard prior to use. https\+://doc.\+photonengine.\+com/en-\/us/pun/v2/gameplay/web-\/extensions/webrpc The Parameters will be converted into JSon format, so make sure your parameters are compatible.

See \doxyref{Photon.\+Realtime.\+IWeb\+Rpc\+Callback.\+On\+Web\+Rpc\+Response}{p.}{interface_photon_1_1_realtime_1_1_i_web_rpc_callback_a75f0eb120e297c22bac5511fbdbec541} on how to get a response.

It\textquotesingle{}s important to understand that the Operation\+Response only tells if the Web\+RPC could be called. The content of the response contains any values your web-\/service sent and the error/success code. In case the web-\/service failed, an error code and a debug message are usually inside the Operation\+Response.

The class Web\+Rpc\+Response is a helper-\/class that extracts the most valuable content from the Web\+RPC response. 

\doxyref{Example}{p.}{namespace_photon_1_1_pun_1_1_example} callback implementation\+:
\begin{DoxyPre}

public void OnWebRpcResponse(OperationResponse response)
\{
    WebRpcResponse webResponse = new WebRpcResponse(operationResponse);
    if (webResponse.ReturnCode != 0) \{ //...
    \}

    switch (webResponse.Name) \{ //...
    \}
    // and so on
\}\end{DoxyPre}
 

Definition at line \textbf{ 3147} of file \textbf{ Photon\+Network.\+cs}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aec48642992944ee0a7ea14bd4c51a8a1_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_photon_1_1_pun_1_1_photon_network_aec48642992944ee0a7ea14bd4c51a8a1_icgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3599fcd464562cb936006da206361cdd}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ConnectMethod@{ConnectMethod}}
\index{ConnectMethod@{ConnectMethod}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ConnectMethod}
{\footnotesize\ttfamily \textbf{ Connect\+Method} Photon.\+Pun.\+Photon\+Network.\+Connect\+Method = \textbf{ Connect\+Method.\+Not\+Called}\hspace{0.3cm}{\ttfamily [static]}}



Tracks, which Connect method was called last. 

Connect\+To\+Master sets this to Connect\+To\+Master. Connect\+To\+Region sets this to Connect\+To\+Region. Connect\+To\+Best\+Cloud\+Server sets this to Connect\+To\+Best. \doxyref{Photon\+Network.\+Connect\+Using\+Settings}{p.}{class_photon_1_1_pun_1_1_photon_network_a3eaa67a8c2af70028949403df6b60ca2} will call either Connect\+To\+Master, Connect\+To\+Region or Connect\+To\+Best, depending on the settings. 

Definition at line \textbf{ 252} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae1c7ae163d79676520bd4bd06fff447d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!EnableCloseConnection@{EnableCloseConnection}}
\index{EnableCloseConnection@{EnableCloseConnection}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{EnableCloseConnection}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Enable\+Close\+Connection = false\hspace{0.3cm}{\ttfamily [static]}}



Used to enable reaction to Close\+Connection events. 

Default\+: false. 

Using Close\+Connection is a security risk, as exploiters can send the event as Master Client.

In best case, a game would implement this \char`\"{}disconnect others\char`\"{} independently from PUN in game-\/code with some security checks. 

Definition at line \textbf{ 410} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aa8af6239914ab71acd29b56e9610f534}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LogLevel@{LogLevel}}
\index{LogLevel@{LogLevel}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LogLevel}
{\footnotesize\ttfamily \textbf{ Pun\+Log\+Level} Photon.\+Pun.\+Photon\+Network.\+Log\+Level = \textbf{ Pun\+Log\+Level.\+Errors\+Only}\hspace{0.3cm}{\ttfamily [static]}}



Controls how verbose PUN is. 



Definition at line \textbf{ 323} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac1319ff7be49947b7018f18b438d175c}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!MAX\_VIEW\_IDS@{MAX\_VIEW\_IDS}}
\index{MAX\_VIEW\_IDS@{MAX\_VIEW\_IDS}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{MAX\_VIEW\_IDS}
{\footnotesize\ttfamily readonly int Photon.\+Pun.\+Photon\+Network.\+MAX\+\_\+\+VIEW\+\_\+\+IDS = 1000\hspace{0.3cm}{\ttfamily [static]}}



The maximum number of assigned Photon\+Views {\itshape per player} (or scene). 

See the General Documentation topic \char`\"{}\+Limitations\char`\"{} on how to raise this limitation. 

Definition at line \textbf{ 106} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a556ed319440663839859373a421ab345}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!MinimalTimeScaleToDispatchInFixedUpdate@{MinimalTimeScaleToDispatchInFixedUpdate}}
\index{MinimalTimeScaleToDispatchInFixedUpdate@{MinimalTimeScaleToDispatchInFixedUpdate}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{MinimalTimeScaleToDispatchInFixedUpdate}
{\footnotesize\ttfamily float Photon.\+Pun.\+Photon\+Network.\+Minimal\+Time\+Scale\+To\+Dispatch\+In\+Fixed\+Update = -\/1f\hspace{0.3cm}{\ttfamily [static]}}



Affects if the \doxyref{Photon\+Handler}{p.}{class_photon_1_1_pun_1_1_photon_handler} dispatches incoming messages in Late\+Update or Fixed\+Update (default). 

By default the \doxyref{Photon\+Handler}{p.}{class_photon_1_1_pun_1_1_photon_handler} component dispatches incoming messages in Fixed\+Update.

When the Time.\+time\+Scale is low, Fixed\+Update is called less frequently up to a point where updates may get paused. PUN can automatically dispatch messages in Late\+Update for low time\+Scale values (when Time.\+time\+Scale is lower than this value).

PUN will use either Fixed\+Update or Late\+Update but not both (as of v2.\+23).

When you use this value, be aware that Instantiates and RPCs execute with a changed timing within a frame. If Instantiate is called from Fixed\+Update, the physics engine seems to run for instantiated objects before the engine calls Start() on them.

By default, this value is -\/1f, so there is no fallback to Late\+Update. 

Definition at line \textbf{ 802} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a312fc99165f039e31b65bebbafdf6736}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!NetworkingClient@{NetworkingClient}}
\index{NetworkingClient@{NetworkingClient}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{NetworkingClient}
{\footnotesize\ttfamily \textbf{ Load\+Balancing\+Client} Photon.\+Pun.\+Photon\+Network.\+Networking\+Client\hspace{0.3cm}{\ttfamily [static]}}



The Load\+Balancing\+Client is part of \doxyref{Photon}{p.}{namespace_photon} \doxyref{Realtime}{p.}{namespace_photon_1_1_realtime} and wraps up multiple servers and states for PUN.



Definition at line \textbf{ 101} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aa3e2d62799e2a42465d46bbdaea3332d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ObjectsInOneUpdate@{ObjectsInOneUpdate}}
\index{ObjectsInOneUpdate@{ObjectsInOneUpdate}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ObjectsInOneUpdate}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Objects\+In\+One\+Update = 20\hspace{0.3cm}{\ttfamily [static]}}



Defines how many updated produced by On\+Photon\+Serialize() are batched into one message. 

A low number increases overhead, a high number might lead to fragmented messages. 

Definition at line \textbf{ 1518} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a4b39e118b6ff0847b0fbca8885a5865d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PrecisionForFloatSynchronization@{PrecisionForFloatSynchronization}}
\index{PrecisionForFloatSynchronization@{PrecisionForFloatSynchronization}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PrecisionForFloatSynchronization}
{\footnotesize\ttfamily float Photon.\+Pun.\+Photon\+Network.\+Precision\+For\+Float\+Synchronization = 0.\+01f\hspace{0.3cm}{\ttfamily [static]}}



The minimum difference between floats before we send it via a \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}\textquotesingle{}s On\+Serialize/\+Observing\+Component. 



Definition at line \textbf{ 428} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a77e14f7cd9ec6dcad2565bf1c56963e7}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PrecisionForQuaternionSynchronization@{PrecisionForQuaternionSynchronization}}
\index{PrecisionForQuaternionSynchronization@{PrecisionForQuaternionSynchronization}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PrecisionForQuaternionSynchronization}
{\footnotesize\ttfamily float Photon.\+Pun.\+Photon\+Network.\+Precision\+For\+Quaternion\+Synchronization = 1.\+0f\hspace{0.3cm}{\ttfamily [static]}}



The minimum angle that a rotation needs to change before we send it via a \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}\textquotesingle{}s On\+Serialize/\+Observing\+Component. 



Definition at line \textbf{ 423} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae1b4f8fe1529076624d34c9ac6c13cd1}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PrecisionForVectorSynchronization@{PrecisionForVectorSynchronization}}
\index{PrecisionForVectorSynchronization@{PrecisionForVectorSynchronization}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PrecisionForVectorSynchronization}
{\footnotesize\ttfamily float Photon.\+Pun.\+Photon\+Network.\+Precision\+For\+Vector\+Synchronization = 0.\+000099f\hspace{0.3cm}{\ttfamily [static]}}



The minimum difference that a Vector2 or Vector3(e.\+g. 

a transforms rotation) needs to change before we send it via a \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}\textquotesingle{}s On\+Serialize/\+Observing\+Component. 

Note that this is the sqr\+Magnitude. E.\+g. to send only after a 0.\+01 change on the Y-\/axix, we use 0.\+01f$\ast$0.01f=0.\+0001f. As a remedy against float inaccuracy we use 0.\+000099f instead of 0.\+0001f. 

Definition at line \textbf{ 418} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aab822b6132ca8d749211babcc69eb79f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PunVersion@{PunVersion}}
\index{PunVersion@{PunVersion}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PunVersion}
{\footnotesize\ttfamily const string Photon.\+Pun.\+Photon\+Network.\+Pun\+Version = \char`\"{}2.\+40\char`\"{}\hspace{0.3cm}{\ttfamily [static]}}



Version number of PUN. Used in the App\+Version, which separates your playerbase in matchmaking.



Definition at line \textbf{ 67} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a7f6405afdd368f941f90aaf85a4bfc0e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!RunRpcCoroutines@{RunRpcCoroutines}}
\index{RunRpcCoroutines@{RunRpcCoroutines}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{RunRpcCoroutines}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Run\+Rpc\+Coroutines = true\hspace{0.3cm}{\ttfamily [static]}}



If an RPC method is implemented as coroutine, it gets started, unless this value is false. 

As starting coroutines causes a little memnory garbage, you may want to disable this option but it is also good enough to not return IEnumerable from methods with the attribite \doxyref{Pun\+RPC}{p.}{class_photon_1_1_pun_1_1_pun_r_p_c}. 

Definition at line \textbf{ 222} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a91a3d63d8d710b87e145a9b6a18a17e0}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ServerSettingsFileName@{ServerSettingsFileName}}
\index{ServerSettingsFileName@{ServerSettingsFileName}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ServerSettingsFileName}
{\footnotesize\ttfamily const string Photon.\+Pun.\+Photon\+Network.\+Server\+Settings\+File\+Name = \char`\"{}Photon\+Server\+Settings\char`\"{}\hspace{0.3cm}{\ttfamily [static]}}



Name of the Photon\+Server\+Settings file (used to load and by \doxyref{Photon\+Editor}{p.}{class_photon_1_1_pun_1_1_photon_editor} to save new files).



Definition at line \textbf{ 110} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac8b6b2e4fb47c0669fa623dec5645570}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SyncCompressed@{SyncCompressed}}
\index{SyncCompressed@{SyncCompressed}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SyncCompressed}
{\footnotesize\ttfamily const int Photon.\+Pun.\+Photon\+Network.\+Sync\+Compressed = 1\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 1877} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a64300f3e69063fab23cbca77630710cd}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SyncFirstValue@{SyncFirstValue}}
\index{SyncFirstValue@{SyncFirstValue}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SyncFirstValue}
{\footnotesize\ttfamily const int Photon.\+Pun.\+Photon\+Network.\+Sync\+First\+Value = 3\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 1879} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a0185ef3c9a6bbc813e98bb4ab8b9b9aa}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SyncNullValues@{SyncNullValues}}
\index{SyncNullValues@{SyncNullValues}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SyncNullValues}
{\footnotesize\ttfamily const int Photon.\+Pun.\+Photon\+Network.\+Sync\+Null\+Values = 2\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 1878} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aa9442689ca13d585f3ee9c602f158015}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SyncViewId@{SyncViewId}}
\index{SyncViewId@{SyncViewId}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SyncViewId}
{\footnotesize\ttfamily const int Photon.\+Pun.\+Photon\+Network.\+Sync\+View\+Id = 0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 1876} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a353dde6242afc859001250fe1ed25ae4}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!UseRpcMonoBehaviourCache@{UseRpcMonoBehaviourCache}}
\index{UseRpcMonoBehaviourCache@{UseRpcMonoBehaviourCache}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{UseRpcMonoBehaviourCache}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Use\+Rpc\+Mono\+Behaviour\+Cache\hspace{0.3cm}{\ttfamily [static]}}



While enabled, the Mono\+Behaviours on which we call RPCs are cached, avoiding costly Get\+Components\texorpdfstring{$<$}{<}Mono\+Behaviour\texorpdfstring{$>$}{>}() calls. 

RPCs are called on the Mono\+Behaviours of a target \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}. Those have to be found via Get\+Components.

When set this to true, the list of Mono\+Behaviours gets cached in each \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}. You can use photon\+View.\+Refresh\+Rpc\+Mono\+Behaviour\+Cache() to manually refresh a \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view}\textquotesingle{}s list of Mono\+Behaviours on demand (when a new Mono\+Behaviour gets added to a networked Game\+Object, e.\+g.). 

Definition at line \textbf{ 209} of file \textbf{ Photon\+Network\+Part.\+cs}.



\doxysubsection{Property Documentation}
\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a0aca35ece2dbbcb313f935c5bbafad84}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AppVersion@{AppVersion}}
\index{AppVersion@{AppVersion}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AppVersion}
{\footnotesize\ttfamily string Photon.\+Pun.\+Photon\+Network.\+App\+Version\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Sent to \doxyref{Photon}{p.}{namespace_photon} Server to specify the \char`\"{}\+Virtual App\+Id\char`\"{}. 

Sent with the operation Authenticate. When using PUN, you should set the Game\+Version or use \doxyref{Connect\+Using\+Settings()}{p.}{class_photon_1_1_pun_1_1_photon_network_a3eaa67a8c2af70028949403df6b60ca2}.

Definition at line \textbf{ 95} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ad9206d09224ee87c9d8eb522efe81e78}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AuthValues@{AuthValues}}
\index{AuthValues@{AuthValues}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AuthValues}
{\footnotesize\ttfamily \textbf{ Authentication\+Values}? Photon.\+Pun.\+Photon\+Network.\+Auth\+Values\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



A user\textquotesingle{}s authentication values used during connect. 

Set these before calling Connect if you want custom authentication. These values set the user\+Id, if and how that user\+Id gets verified (server-\/side), etc..

If authentication fails for any values, PUN will call your implementation of On\+Custom\+Authentication\+Failed(string debug\+Message). See \doxyref{Photon.\+Realtime.\+IConnection\+Callbacks.\+On\+Custom\+Authentication\+Failed}{p.}{interface_photon_1_1_realtime_1_1_i_connection_callbacks_a669ed841654618813e551e11d7686225}. 

Definition at line \textbf{ 279} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a2440ba4650d0f1dbb3d3091bb44758d4}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!AutomaticallySyncScene@{AutomaticallySyncScene}}
\index{AutomaticallySyncScene@{AutomaticallySyncScene}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{AutomaticallySyncScene}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Automatically\+Sync\+Scene\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Defines if all clients in a room should automatically load the same level as the Master Client. 

When enabled, clients load the same scene that is active on the Master Client. When a client joins a room, the scene gets loaded even before the callback On\+Joined\+Room gets called.

To synchronize the loaded level, the Master Client should use \doxyref{Photon\+Network.\+Load\+Level}{p.}{class_photon_1_1_pun_1_1_photon_network_a9aa7d7a2389b180e95c81921076ac056}, which notifies the other clients before starting to load the scene. If the Master Client loads a level directly via Unity\textquotesingle{}s API, PUN will notify the other players after the scene loading completed (using Scene\+Manager.\+scene\+Loaded).

Internally, a Custom Room Property is set for the loaded scene. On change, clients use Load\+Level if they are not in the same scene.

Note that this works only for a single active scene and that reloading the scene is not supported. The Master Client will actually reload a scene but other clients won\textquotesingle{}t. To get everyone to reload, the game can send an RPC or event to trigger the loading. 

Definition at line \textbf{ 509} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a00c321ca2b6e39ab5288f3f40215fb00}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!BestRegionSummaryInPreferences@{BestRegionSummaryInPreferences}}
\index{BestRegionSummaryInPreferences@{BestRegionSummaryInPreferences}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{BestRegionSummaryInPreferences}
{\footnotesize\ttfamily string Photon.\+Pun.\+Photon\+Network.\+Best\+Region\+Summary\+In\+Preferences\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Used to store and access the \char`\"{}\+Best Region Summary\char`\"{} in the Player Preferences. 

Set this value to null before you connect, to discard the previously selected Best Region for the client. 

Definition at line \textbf{ 152} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_af4e7abefb8aee261d72ae828e5856351}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CloudRegion@{CloudRegion}}
\index{CloudRegion@{CloudRegion}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CloudRegion}
{\footnotesize\ttfamily string? Photon.\+Pun.\+Photon\+Network.\+Cloud\+Region\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Currently used Cloud Region (if any). As long as the client is not on a Master Server or Game Server, the region is not yet defined.



Definition at line \textbf{ 133} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a6b18cbd7d25ee55904943346db209108}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CountOfPlayers@{CountOfPlayers}}
\index{CountOfPlayers@{CountOfPlayers}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CountOfPlayers}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Count\+Of\+Players\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The count of players currently using this application (available on Master\+Server in 5sec intervals). 



Definition at line \textbf{ 900} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aec29c68ed56409774a0a77aa73b1bc8d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CountOfPlayersInRooms@{CountOfPlayersInRooms}}
\index{CountOfPlayersInRooms@{CountOfPlayersInRooms}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CountOfPlayersInRooms}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Count\+Of\+Players\+In\+Rooms\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Count of users currently playing your app in some room (sent every 5sec by Master Server). 

Use Photon\+Network.\+Player\+List.\+Length or Photon\+Network.\+Current\+Room.\+Player\+Count to get the count of players in the room you\textquotesingle{}re in! 

Definition at line \textbf{ 889} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a94bc96c001fcee905d962831e154dc7a}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CountOfPlayersOnMaster@{CountOfPlayersOnMaster}}
\index{CountOfPlayersOnMaster@{CountOfPlayersOnMaster}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CountOfPlayersOnMaster}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Count\+Of\+Players\+On\+Master\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The count of players currently looking for a room (available on Master\+Server in 5sec intervals). 



Definition at line \textbf{ 877} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a48adcf58a1e1c0fb4a08a688ad5657be}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CountOfRooms@{CountOfRooms}}
\index{CountOfRooms@{CountOfRooms}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CountOfRooms}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Count\+Of\+Rooms\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The count of rooms currently in use (available on Master\+Server in 5sec intervals). 



Definition at line \textbf{ 911} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a95cb89073aa37d377bb739f29c18b40c}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CrcCheckEnabled@{CrcCheckEnabled}}
\index{CrcCheckEnabled@{CrcCheckEnabled}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CrcCheckEnabled}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Crc\+Check\+Enabled\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Crc checks can be useful to detect and avoid issues with broken datagrams. Can be enabled while not connected.



Definition at line \textbf{ 951} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac9170d0d4ba782a17096fff7c69598c4}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CurrentCluster@{CurrentCluster}}
\index{CurrentCluster@{CurrentCluster}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CurrentCluster}
{\footnotesize\ttfamily string? Photon.\+Pun.\+Photon\+Network.\+Current\+Cluster\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The cluster name provided by the Name Server. 

The value is provided by the Op\+Response for Op\+Authenticate/\+Op\+Authenticate\+Once. See Connect\+To\+Region.

Null until set.

Note that the Name Server may assign another cluster, if the requested one is not configured or available. 

Definition at line \textbf{ 143} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a476df42d265a14ccfac89735fd56e6d8}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CurrentLobby@{CurrentLobby}}
\index{CurrentLobby@{CurrentLobby}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CurrentLobby}
{\footnotesize\ttfamily \textbf{ Typed\+Lobby} Photon.\+Pun.\+Photon\+Network.\+Current\+Lobby\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The lobby that will be used when PUN joins a lobby or creates a game. 

This is defined when joining a lobby or creating rooms 

The default lobby uses an empty string as name. So when you connect or leave a room, PUN automatically gets you into a lobby again.

Check \doxyref{Photon\+Network.\+In\+Lobby}{p.}{class_photon_1_1_pun_1_1_photon_network_ae01598f89f35258f1c991da26d9d1f22} if the client is in a lobby. (master\+Server\+And\+Lobby) 

Definition at line \textbf{ 296} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a5339e137c6b1461d090f658012ee62c7}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!CurrentRoom@{CurrentRoom}}
\index{CurrentRoom@{CurrentRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{CurrentRoom}
{\footnotesize\ttfamily \textbf{ Room}? Photon.\+Pun.\+Photon\+Network.\+Current\+Room\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Get the room we\textquotesingle{}re currently in (also when in Offline\+Mode). 

Null if we aren\textquotesingle{}t in any room. 

Load\+Balancing Client is not aware of the \doxyref{Photon}{p.}{namespace_photon} Offline Mode, so never use Photon\+Network.\+Networking\+Client.\+Current\+Room will be null if you are using Off\+Line Mode, while \doxyref{Photon\+Network.\+Current\+Room}{p.}{class_photon_1_1_pun_1_1_photon_network_a5339e137c6b1461d090f658012ee62c7} will be set when offline\+Mode is true 

Definition at line \textbf{ 307} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a294f18797973a310c8c23f25747691c6}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!EnableLobbyStatistics@{EnableLobbyStatistics}}
\index{EnableLobbyStatistics@{EnableLobbyStatistics}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{EnableLobbyStatistics}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Enable\+Lobby\+Statistics\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



If enabled, the client will get a list of available lobbies from the Master Server. 

Set this value before the client connects to the Master Server. While connected to the Master Server, a change has no effect.

Implement Optional\+Info\+Callbacks.\+On\+Lobby\+Statistics\+Update, to get the list of used lobbies.

The lobby statistics can be useful if your title dynamically uses lobbies, depending (e.\+g.) on current player activity or such. In this case, getting a list of available lobbies, their room-\/count and player-\/count can be useful info.

Connect\+Using\+Settings sets this to the Photon\+Server\+Settings value. 

Definition at line \textbf{ 543} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aab2636705ca41bb0c9380be4f55047f7}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!GameVersion@{GameVersion}}
\index{GameVersion@{GameVersion}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{GameVersion}
{\footnotesize\ttfamily string Photon.\+Pun.\+Photon\+Network.\+Game\+Version\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Version number of your game. 

Setting this updates the App\+Version, which separates your playerbase in matchmaking.

In PUN, the Game\+Version is only one component of the \doxyref{Load\+Balancing\+Client.\+App\+Version}{p.}{class_photon_1_1_realtime_1_1_load_balancing_client_a04176f5a1bae0739355809e1eafb609f}. Setting the Game\+Version will also set the \doxyref{Load\+Balancing\+Client.\+App\+Version}{p.}{class_photon_1_1_realtime_1_1_load_balancing_client_a04176f5a1bae0739355809e1eafb609f} to\+: value+\textquotesingle{}\+\_\+\textquotesingle{}+ \doxyref{Photon\+Network.\+Pun\+Version}{p.}{class_photon_1_1_pun_1_1_photon_network_aab822b6132ca8d749211babcc69eb79f}.

The App\+Version is used to split your playerbase as needed. One App\+Id may have various App\+Versions and each is a separate set of users for matchmaking.

The App\+Version gets sent in the \char`\"{}\+Authenticate\char`\"{} step. This means you can set the Game\+Version right after calling Connect\+Using\+Settings (e.\+g.) and the new value will be used on the server. Once the client is connected, authentication is done and the value won\textquotesingle{}t be sent to the server anymore. 

Definition at line \textbf{ 81} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae01598f89f35258f1c991da26d9d1f22}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!InLobby@{InLobby}}
\index{InLobby@{InLobby}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{InLobby}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+In\+Lobby\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



True while this client is in a lobby. 

Implement IPun\+Callbacks.\+On\+Room\+List\+Update() for a notification when the list of rooms becomes available or updated.

You are automatically leaving any lobby when you join a room! Lobbies only exist on the Master Server (whereas rooms are handled by Game Servers). 

Definition at line \textbf{ 560} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_acd3228520b05c60cddddb9a3b75f3b1d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!InRoom@{InRoom}}
\index{InRoom@{InRoom}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{InRoom}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+In\+Room\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Is true while being in a room (Network\+Client\+State == Client\+State.\+Joined). 

Aside from polling this value, game logic should implement IMatchmaking\+Callbacks in some class and react when that gets called.~\newline


Many actions can only be executed in a room, like Instantiate or Leave, etc.~\newline
 A client can join a room in offline mode. In that case, don\textquotesingle{}t use \doxyref{Load\+Balancing\+Client.\+In\+Room}{p.}{class_photon_1_1_realtime_1_1_load_balancing_client_aabf5b0aaecb05bc81ca7811e5630d05a}, which does not cover offline mode. 

Definition at line \textbf{ 864} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_abfb28d4211e3d74568e4250edf231b0f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!IsConnected@{IsConnected}}
\index{IsConnected@{IsConnected}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{IsConnected}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Is\+Connected\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



False until you connected to \doxyref{Photon}{p.}{namespace_photon} initially. 

True immediately after Connect-\/call, in offline mode, while connected to any server and even while switching servers. 

It is recommended to use the IConnection\+Callbacks to establish a connection workflow. Also have a look at Is\+Connected\+And\+Ready, which provides more info on when you can call operations at all. 

Definition at line \textbf{ 178} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a479bd31a8df0d484a8b2a665e4f41b18}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!IsConnectedAndReady@{IsConnectedAndReady}}
\index{IsConnectedAndReady@{IsConnectedAndReady}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{IsConnectedAndReady}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Is\+Connected\+And\+Ready\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



A refined version of connected which is true only if your connection to the server is ready to accept operations like join, leave, etc. 



Definition at line \textbf{ 199} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ac00d87d1bbd7d63fa13e6d1823e2f576}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!IsMasterClient@{IsMasterClient}}
\index{IsMasterClient@{IsMasterClient}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{IsMasterClient}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Is\+Master\+Client\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Are we the master client? 



Definition at line \textbf{ 808} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a0ac7974d889dbb6498a161e62be6e4ff}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!IsMessageQueueRunning@{IsMessageQueueRunning}}
\index{IsMessageQueueRunning@{IsMessageQueueRunning}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{IsMessageQueueRunning}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Is\+Message\+Queue\+Running\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Can be used to pause dispatching of incoming events (RPCs, Instantiates and anything else incoming). 

While Is\+Message\+Queue\+Running == false, the On\+Photon\+Serialize\+View calls are not done and nothing is sent by a client. Also, incoming messages will be queued until you re-\/activate the message queue.

This can be useful if you first want to load a level, then go on receiving data of Photon\+Views and RPCs. The client will go on receiving and sending acknowledgements for incoming packages and your RPCs/\+Events. This adds \char`\"{}lag\char`\"{} and can cause issues when the pause is longer, as all incoming messages are just queued. 

Definition at line \textbf{ 664} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a4696e3eb91e482ff0188b2e9102fd640}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!KeepAliveInBackground@{KeepAliveInBackground}}
\index{KeepAliveInBackground@{KeepAliveInBackground}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{KeepAliveInBackground}
{\footnotesize\ttfamily float? Photon.\+Pun.\+Photon\+Network.\+Keep\+Alive\+In\+Background\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Defines how many seconds PUN keeps the connection after Unity\textquotesingle{}s On\+Application\+Pause(true) call. 

Default\+: 60 seconds. 

It\textquotesingle{}s best practice to disconnect inactive apps/connections after a while but to also allow users to take calls, etc.. We think a reasonable background timeout is 60 seconds.

To handle the timeout, implement\+: On\+Disconnected(), as usual. Your application will \char`\"{}notice\char`\"{} the background disconnect when it becomes active again (running the Update() loop).

If you need to separate this case from others, you need to track if the app was in the background (there is no special callback by PUN).

Info\+: PUN is running a \char`\"{}fallback thread\char`\"{} to send ACKs to the server, even when Unity is not calling Update() regularly. This helps keeping the connection while loading scenes and assets and when the app is in the background.

Note\+: Some platforms (e.\+g. i\+OS) don\textquotesingle{}t allow to keep a connection while the app is in background. In those cases, this value does not change anything, the app immediately loses connection in background.

Unity\textquotesingle{}s On\+Application\+Pause() callback is broken in some exports (Android) of some Unity versions. Make sure On\+Application\+Pause() gets the callbacks you expect on the platform you target! Check Photon\+Handler.\+On\+Application\+Pause(bool pause) to see the implementation. 

Definition at line \textbf{ 774} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a12a1a136d0ad40dad66af5373a21a222}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LevelLoadingProgress@{LevelLoadingProgress}}
\index{LevelLoadingProgress@{LevelLoadingProgress}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LevelLoadingProgress}
{\footnotesize\ttfamily float Photon.\+Pun.\+Photon\+Network.\+Level\+Loading\+Progress\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Represents the scene loading progress when using \doxyref{Load\+Level()}{p.}{class_photon_1_1_pun_1_1_photon_network_a9aa7d7a2389b180e95c81921076ac056}. 

The value is 0 if the app never loaded a scene with \doxyref{Load\+Level()}{p.}{class_photon_1_1_pun_1_1_photon_network_a9aa7d7a2389b180e95c81921076ac056}. During async scene loading, the value is between 0 and 1. Once any scene completed loading, it stays at 1 (signaling \char`\"{}done\char`\"{}). 

The level loading progress. Ranges from 0 to 1.

Definition at line \textbf{ 239} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3941fc37f654b2010d53097dae17f724}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!LocalPlayer@{LocalPlayer}}
\index{LocalPlayer@{LocalPlayer}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{LocalPlayer}
{\footnotesize\ttfamily \textbf{ Player} Photon.\+Pun.\+Photon\+Network.\+Local\+Player\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



This client\textquotesingle{}s Player instance is always available, unless the app shuts down. 

Useful (e.\+g.) to set the Custom Player Properties or the Nick\+Name for this client anytime. When the client joins a room, the Custom Properties and other values are synced. 

Definition at line \textbf{ 332} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a7ab30903c626b476fb4500ba897da7d4}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!MasterClient@{MasterClient}}
\index{MasterClient@{MasterClient}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{MasterClient}
{\footnotesize\ttfamily \textbf{ Player} Photon.\+Pun.\+Photon\+Network.\+Master\+Client\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The Master Client of the current room or null (outside of rooms). 

Can be used as \char`\"{}authoritative\char`\"{} client/player to make descisions, run AI or other.

If the current Master Client leaves the room (leave/disconnect), the server will quickly assign someone else. If the current Master Client times out (closed app, lost connection, etc), messages sent to this client are effectively lost for the others! A timeout can take 10 seconds in which no Master Client is active.

Implement the method IPun\+Callbacks.\+On\+Master\+Client\+Switched to be called when the Master Client switched.

Use \doxyref{Photon\+Network.\+Set\+Master\+Client}{p.}{class_photon_1_1_pun_1_1_photon_network_a79ead2d883073a16d4ae87d973499960}, to switch manually to some other player / client.

With Offline\+Mode == true, this always returns the Photon\+Network.\+player. 

Definition at line \textbf{ 837} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a705868d3b1bf11454590b6d38c578346}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!MaxResendsBeforeDisconnect@{MaxResendsBeforeDisconnect}}
\index{MaxResendsBeforeDisconnect@{MaxResendsBeforeDisconnect}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{MaxResendsBeforeDisconnect}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Max\+Resends\+Before\+Disconnect\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Defines the number of times a reliable message can be resent before not getting an ACK for it will trigger a disconnect. 

Default\+: 5.

Less resends mean quicker disconnects, while more can lead to much more lag without helping. Min\+: 3. Max\+: 10.

Definition at line \textbf{ 975} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a6ced17c19314be4dbd68c83d99a6df9e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!NetworkClientState@{NetworkClientState}}
\index{NetworkClientState@{NetworkClientState}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{NetworkClientState}
{\footnotesize\ttfamily \textbf{ Client\+State}? Photon.\+Pun.\+Photon\+Network.\+Network\+Client\+State\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Directly provides the network-\/level client state, unless in Offline\+Mode. 

In context of PUN, you should usually use Is\+Connected or Is\+Connected\+And\+Ready.

This is the lower level connection state. Keep in mind that PUN uses more than one server, so the client may become Disconnected, even though it\textquotesingle{}s just switching servers.

While Offline\+Mode is true, this is Client\+State.\+Joined (after create/join) or Connected\+To\+Master\+Server in all other cases. 

Definition at line \textbf{ 227} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a3ac3056a3bc8e6593375b2e852d85d24}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!NetworkStatisticsEnabled@{NetworkStatisticsEnabled}}
\index{NetworkStatisticsEnabled@{NetworkStatisticsEnabled}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{NetworkStatisticsEnabled}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Network\+Statistics\+Enabled\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Enables or disables the collection of statistics about this client\textquotesingle{}s traffic. 

If you encounter issues with clients, the traffic stats are a good starting point to find solutions. Only with enabled stats, you can use Get\+Vital\+Stats 

Definition at line \textbf{ 926} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_adfce2d94ddd3b82e5bd45b2772d0f35e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!NickName@{NickName}}
\index{NickName@{NickName}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{NickName}
{\footnotesize\ttfamily string Photon.\+Pun.\+Photon\+Network.\+Nick\+Name\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Set to synchronize the player\textquotesingle{}s nickname with everyone in the room(s) you enter. 

This sets Photon\+Network.\+player.\+Nick\+Name. 

The Nick\+Name is just a nickname and does not have to be unique or backed up with some account.~\newline
 Set the value any time (e.\+g. before you connect) and it will be available to everyone you play with.~\newline
 Access the names of players by\+: \doxyref{Player.\+Nick\+Name}{p.}{class_photon_1_1_realtime_1_1_player_adf7350041e899cf8138dc2c31e2bbb62}. ~\newline
 \doxyref{Photon\+Network.\+Player\+List\+Others}{p.}{class_photon_1_1_pun_1_1_photon_network_a020beb53dd60caba8657f52258033549} is a list of other players -\/ each contains the Nick\+Name the remote player set. 

Definition at line \textbf{ 354} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a57451f77a1536bfa1a1688d8c6f8ee9f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!OfflineMode@{OfflineMode}}
\index{OfflineMode@{OfflineMode}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{OfflineMode}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Offline\+Mode\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Offline mode can be set to re-\/use your multiplayer code in singleplayer game modes. 

When this is on \doxyref{Photon\+Network}{p.}{class_photon_1_1_pun_1_1_photon_network} will not create any connections and there is near to no overhead. Mostly usefull for reusing RPC\textquotesingle{}s and \doxyref{Photon\+Network.\+Instantiate}{p.}{class_photon_1_1_pun_1_1_photon_network_a3c3998fe3bc09a7de8d09378d7a3e2d0} 

Definition at line \textbf{ 436} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aaa5fd00c5f6eba2c26ef7b89d04a5f7e}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PacketLossByCrcCheck@{PacketLossByCrcCheck}}
\index{PacketLossByCrcCheck@{PacketLossByCrcCheck}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PacketLossByCrcCheck}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Packet\+Loss\+By\+Crc\+Check\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



If Crc\+Check\+Enabled, this counts the incoming packages that don\textquotesingle{}t have a valid CRC checksum and got rejected.



Definition at line \textbf{ 968} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a44320ea58c806435375af9fedaafc56d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PhotonServerSettings@{PhotonServerSettings}}
\index{PhotonServerSettings@{PhotonServerSettings}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PhotonServerSettings}
{\footnotesize\ttfamily \textbf{ Server\+Settings} Photon.\+Pun.\+Photon\+Network.\+Photon\+Server\+Settings\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Serialized server settings, written by the Setup Wizard for use in Connect\+Using\+Settings.



Definition at line \textbf{ 115} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ad1d644efe090df91db9623e4b5293c7d}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PhotonViewCollection@{PhotonViewCollection}}
\index{PhotonViewCollection@{PhotonViewCollection}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PhotonViewCollection}
{\footnotesize\ttfamily Non\+Alloc\+Dictionary$<$int, \textbf{ Photon\+View}$>$.Value\+Iterator Photon.\+Pun.\+Photon\+Network.\+Photon\+View\+Collection\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Returns a new iterable collection of current photon views. 

You can iterate over all Photon\+Views in a simple foreach loop. To use this in a while-\/loop, assign the new iterator to a variable and then call Move\+Next on that. 

Definition at line \textbf{ 76} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a8f31f2a062373da798041e19084af804}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PhotonViews@{PhotonViews}}
\index{PhotonViews@{PhotonViews}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PhotonViews}
{\footnotesize\ttfamily \textbf{ Photon\+View} [$\,$] Photon.\+Pun.\+Photon\+Network.\+Photon\+Views\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Gets the photon views. 

This is an expensive operation as it returns a copy of the internal list. 

The photon views.

Definition at line \textbf{ 54} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a13cd7f74a3672513b43bf224968eb9de}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PlayerList@{PlayerList}}
\index{PlayerList@{PlayerList}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PlayerList}
{\footnotesize\ttfamily \textbf{ Player} [$\,$] Photon.\+Pun.\+Photon\+Network.\+Player\+List\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



A sorted copy of the players-\/list of the current room. 

This is using Linq, so better cache this value. Update when players join / leave. 

Definition at line \textbf{ 370} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a020beb53dd60caba8657f52258033549}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PlayerListOthers@{PlayerListOthers}}
\index{PlayerListOthers@{PlayerListOthers}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PlayerListOthers}
{\footnotesize\ttfamily \textbf{ Player} [$\,$] Photon.\+Pun.\+Photon\+Network.\+Player\+List\+Others\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



A sorted copy of the players-\/list of the current room, excluding this client. 

This is using Linq, so better cache this value. Update when players join / leave. 

Definition at line \textbf{ 387} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ab4dd61936d6f0060d7317607076071bf}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!PrefabPool@{PrefabPool}}
\index{PrefabPool@{PrefabPool}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{PrefabPool}
{\footnotesize\ttfamily \textbf{ IPun\+Prefab\+Pool} Photon.\+Pun.\+Photon\+Network.\+Prefab\+Pool\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



An Object Pool can be used to keep and reuse instantiated object instances. 

Replaces Unity\textquotesingle{}s default Instantiate and Destroy methods. 

Defaults to the \doxyref{Default\+Pool}{p.}{class_photon_1_1_pun_1_1_default_pool} type. To use a Game\+Object pool, implement \doxyref{IPun\+Prefab\+Pool}{p.}{interface_photon_1_1_pun_1_1_i_pun_prefab_pool} and assign it here. Prefabs are identified by name. 

Definition at line \textbf{ 177} of file \textbf{ Photon\+Network\+Part.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a16baa5d3afe9edc75852217535bfd583}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!QuickResends@{QuickResends}}
\index{QuickResends@{QuickResends}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{QuickResends}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Quick\+Resends\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



In case of network loss, reliable messages can be repeated quickly up to 3 times. 

When reliable messages get lost more than once, subsequent repeats are delayed a bit to allow the network to recover.~\newline
 With this option, the repeats 2 and 3 can be sped up. This can help avoid timeouts but also it increases the speed in which gaps are closed.~\newline
 When you set this, increase \doxyref{Photon\+Network.\+Max\+Resends\+Before\+Disconnect}{p.}{class_photon_1_1_pun_1_1_photon_network_a705868d3b1bf11454590b6d38c578346} to 6 or 7. 

Definition at line \textbf{ 994} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_acb5a636cb8fdc446ae4607b2c8f0219c}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ResentReliableCommands@{ResentReliableCommands}}
\index{ResentReliableCommands@{ResentReliableCommands}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ResentReliableCommands}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Resent\+Reliable\+Commands\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Count of commands that got repeated (due to local repeat-\/timing before an ACK was received). 

If this value increases a lot, there is a good chance that a timeout disconnect will happen due to bad conditions. 

Definition at line \textbf{ 945} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a84b1a2edd7844e3f42b1e58e6b4fc9c8}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SendRate@{SendRate}}
\index{SendRate@{SendRate}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SendRate}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Send\+Rate\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Defines how many times per second the \doxyref{Photon\+Handler}{p.}{class_photon_1_1_pun_1_1_photon_handler} should send data, if any is queued. 

Default\+: 30. 

This value defines how often PUN will call the low level Photon\+Peer to put queued outgoing messages into a datagram to be sent. This is implemented in the \doxyref{Photon\+Handler}{p.}{class_photon_1_1_pun_1_1_photon_handler} component, which integrates PUN into the Unity game loop. The \doxyref{Photon\+Handler.\+Max\+Datagrams}{p.}{class_photon_1_1_pun_1_1_photon_handler_a5491e28e5a2906be4504f5543e404922} value defines how many datagrams can be sent in one iteration.

This value does not affect how often updates are written by Photon\+Views. That is controlled by the Serialization\+Rate. To avoid send-\/delays for \doxyref{Photon\+View}{p.}{class_photon_1_1_pun_1_1_photon_view} updates, PUN will also send data at the end of frames that wrote data in On\+Photon\+Serialize\+View, so sending may actually be more frequent than the Send\+Rate.

Messages queued due to RPCs and Raise\+Event, will be sent with at least Send\+Rate frequency. They are included, when On\+Photon\+Serialize wrote updates and triggers early sending.

Setting this value does not adjust the Serialization\+Rate anymore (as of PUN 2.\+24).

Sending less often will aggregate messages in datagrams, which avoids overhead on the network. It is also important to not push too many datagrams per frame. Three to five seem to be the sweet spot.

Keep your target platform in mind\+: mobile networks are usually slower. Wi\+Fi is slower with more variance and bursts of loss.

A low framerate (as in Update calls) will affect sending of messages. 

Definition at line \textbf{ 596} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_add2c5cc89d654a90db576bc9a6e0411f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!SerializationRate@{SerializationRate}}
\index{SerializationRate@{SerializationRate}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{SerializationRate}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Serialization\+Rate\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Defines how many times per second On\+Photon\+Serialize should be called on Photon\+Views for controlled objects. 

This value defines how often PUN will call On\+Photon\+Serialize on controlled network objects. This is implemented in the \doxyref{Photon\+Handler}{p.}{class_photon_1_1_pun_1_1_photon_handler} component, which integrates PUN into the Unity game loop.

The updates written in On\+Photon\+Serialize will be queued temporarily and sent in the next Late\+Update, so a high Serialization\+Rate also causes more sends. The idea is to keep the delay short during which written updates are queued.

Calling RPCs will not trigger a send.

A low framerate will affect how frequent updates are written and how \char`\"{}on time\char`\"{} they are.

A lower rate takes up less performance but the receiving side needs to interpolate longer times between updates. 

Definition at line \textbf{ 633} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_abbb2b33d7b82a1822a080ac51945db0b}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!Server@{Server}}
\index{Server@{Server}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{Server}
{\footnotesize\ttfamily \textbf{ Server\+Connection}?? Photon.\+Pun.\+Photon\+Network.\+Server\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The server (type) this client is currently connected or connecting to. 

\doxyref{Photon}{p.}{namespace_photon} uses 3 different roles of servers\+: Name Server, Master Server and Game Server.

Definition at line \textbf{ 257} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aaa82d2469dcf203bb7c0d77ad32e1b21}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ServerAddress@{ServerAddress}}
\index{ServerAddress@{ServerAddress}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ServerAddress}
{\footnotesize\ttfamily string? Photon.\+Pun.\+Photon\+Network.\+Server\+Address\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Currently used server address (no matter if master or game server).



Definition at line \textbf{ 130} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a195d13cd2f7de13ecb9fa42a1702ce6f}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ServerPortOverrides@{ServerPortOverrides}}
\index{ServerPortOverrides@{ServerPortOverrides}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ServerPortOverrides}
{\footnotesize\ttfamily \textbf{ Photon\+Port\+Definition}? Photon.\+Pun.\+Photon\+Network.\+Server\+Port\+Overrides\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Defines overrides for server ports. 

Used per server-\/type if \texorpdfstring{$>$}{>} 0. Important\+: If you change the transport protocol, adjust the overrides, too.

\doxyref{Load\+Balancing\+Client.\+Server\+Port\+Overrides}{p.}{class_photon_1_1_realtime_1_1_load_balancing_client_aa56ac38654f2867927d92db331d8d18b} 

Definition at line \textbf{ 1012} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_ae1b1a5deb3158065875cbf357827e420}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ServerTimestamp@{ServerTimestamp}}
\index{ServerTimestamp@{ServerTimestamp}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ServerTimestamp}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+Server\+Timestamp\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The current server\textquotesingle{}s millisecond timestamp. 

This can be useful to sync actions and events on all clients in one room. The timestamp is based on the server\textquotesingle{}s Environment.\+Tick\+Count.

It will overflow from a positive to a negative value every so often, so be careful to use only time-\/differences to check the Time delta when things happen.

This is the basis for \doxyref{Photon\+Network.\+Time}{p.}{class_photon_1_1_pun_1_1_photon_network_a34964303a3ad5074da94cc1cd6f70a74}. 

Definition at line \textbf{ 727} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a34964303a3ad5074da94cc1cd6f70a74}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!Time@{Time}}
\index{Time@{Time}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{Time}
{\footnotesize\ttfamily double Photon.\+Pun.\+Photon\+Network.\+Time\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



\doxyref{Photon}{p.}{namespace_photon} network time, synched with the server. 

v1.\+55~\newline
 This time value depends on the server\textquotesingle{}s Environment.\+Tick\+Count. It is different per server but inside a Room, all clients should have the same value (Rooms are on one server only).~\newline
 This is not a Date\+Time!~\newline


Use this value with care\+: ~\newline
 It can start with any positive value.~\newline
 It will \char`\"{}wrap around\char`\"{} from 4294967.\+295 to 0! 

Definition at line \textbf{ 694} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_a16d9fbf0248db8d2c9e3fec6204e676c}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!UseAlternativeUdpPorts@{UseAlternativeUdpPorts}}
\index{UseAlternativeUdpPorts@{UseAlternativeUdpPorts}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{UseAlternativeUdpPorts}
{\footnotesize\ttfamily bool Photon.\+Pun.\+Photon\+Network.\+Use\+Alternative\+Udp\+Ports\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}, {\ttfamily [set]}}



Replaced by Server\+Port\+Overrides.



Definition at line \textbf{ 1008} of file \textbf{ Photon\+Network.\+cs}.

\mbox{\label{class_photon_1_1_pun_1_1_photon_network_aa32dbfcd3525505b8fb104d87bb52098}} 
\index{Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}!ViewCount@{ViewCount}}
\index{ViewCount@{ViewCount}!Photon.Pun.PhotonNetwork@{Photon.Pun.PhotonNetwork}}
\doxysubsubsection{ViewCount}
{\footnotesize\ttfamily int Photon.\+Pun.\+Photon\+Network.\+View\+Count\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Definition at line \textbf{ 84} of file \textbf{ Photon\+Network\+Part.\+cs}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+\_\+\+SSDSPEEDUP/2021/\+GPS/gps2\+\_\+purrpatrator/\+GPS2\+\_\+\+Purrpatrator/\+Assets/\+Photon/\+Photon\+Unity\+Networking/\+Code/\textbf{ Photon\+Network.\+cs}\item 
C\+:/\+\_\+\+SSDSPEEDUP/2021/\+GPS/gps2\+\_\+purrpatrator/\+GPS2\+\_\+\+Purrpatrator/\+Assets/\+Photon/\+Photon\+Unity\+Networking/\+Code/\textbf{ Photon\+Network\+Part.\+cs}\end{DoxyCompactItemize}
