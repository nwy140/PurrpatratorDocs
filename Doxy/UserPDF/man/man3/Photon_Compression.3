.TH "Photon.Compression" 3 "Mon Apr 18 2022" "Purrpatrator User manual" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Photon.Compression \- Temporariliy using the \fBUtilities\fP namespace to avoid collisions with the DLL still in use by NST  

.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBHalfFloat\fP"
.br
.ti -1c
.RI "namespace \fBInternal\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBArrayPackBitsExt\fP"
.br
.RI "Experimental packers, that counts number of used bits for serialization\&. "
.ti -1c
.RI "class \fBArrayPackBytesExt\fP"
.br
.RI "Experimental packers, that counts number of used bits for serialization\&. "
.ti -1c
.RI "class \fBArraySegmentExt\fP"
.br
.ti -1c
.RI "class \fBArraySerializeExt\fP"
.br
.RI "A Utility class that gives all byte[], uint[] and ulong[] buffers bitpacking/serialization methods\&. "
.ti -1c
.RI "class \fBArraySerializeHalfExt\fP"
.br
.ti -1c
.RI "class \fBArraySerializeUnsafe\fP"
.br
.ti -1c
.RI "class \fBBitCounter\fP"
.br
.RI "Experimental packers, that counts number of used bits for serialization\&. "
.ti -1c
.RI "struct \fBByteConverter\fP"
.br
.ti -1c
.RI "class \fBCompressedElement\fP"
.br
.RI "The compressed result of crushing\&. "
.ti -1c
.RI "class \fBCompressedElementExt\fP"
.br
.ti -1c
.RI "class \fBCompressedMatrix\fP"
.br
.RI "This class contains \fBCompressedElement\fP classes for the compressed Position, Rotation and Scale, and exposes methods for comparing, copying, serialiing and deserializing the entire collection in one call\&. "
.ti -1c
.RI "struct \fBCompressedQuat\fP"
.br
.ti -1c
.RI "struct \fBElement\fP"
.br
.RI "A struct that allows Quaternion and Vector types to be treated as the same\&. "
.ti -1c
.RI "class \fBElementCrusher\fP"
.br
.ti -1c
.RI "class \fBFloatCrusherExtensions\fP"
.br
.ti -1c
.RI "interface \fBIHasTransformCrusher\fP"
.br
.RI "VERY basic interface, just to make it easy to find transform crusher in another example component\&. "
.ti -1c
.RI "class \fBIncludeAxisExtensions\fP"
.br
.ti -1c
.RI "interface \fBIOnElementCrusherChange\fP"
.br
.ti -1c
.RI "interface \fBIPackObj\fP"
.br
.ti -1c
.RI "interface \fBIPackObjOnReadyChange\fP"
.br
.ti -1c
.RI "class \fBLiteCrusher\fP"
.br
.ti -1c
.RI "class \fBLiteFloatCrusher\fP"
.br
.ti -1c
.RI "class \fBLiteIntCrusher\fP"
.br
.ti -1c
.RI "class \fBMatrix\fP"
.br
.RI "A class that holds TRS (Position / Rotation / Scale) values as well as a reference to the crusher that was used to restore it, and the RotationType enum to indicate if this is using Quaternion or Eulers for rotation\&. "
.ti -1c
.RI "class \fBMatrixExtensions\fP"
.br
.ti -1c
.RI "class \fBNormCompress\fP"
.br
.RI "Very basic and lightweight compression of floats ranging from 0-1 in value\&. "
.ti -1c
.RI "class \fBPackObjectAttribute\fP"
.br
.ti -1c
.RI "class \fBPackObjectSettings\fP"
.br
.ti -1c
.RI "class \fBPrimitivePackBitsExt\fP"
.br
.RI "Experimental packers, that counts number of used bits for serialization\&. "
.ti -1c
.RI "class \fBPrimitivePackBytesExt\fP"
.br
.RI "Experimental packers, that counts number of used bits for serialization\&. "
.ti -1c
.RI "class \fBPrimitiveSerializeExt\fP"
.br
.RI "Extension methods for writing bits to primitive buffers\&. "
.ti -1c
.RI "class \fBQuatCrusher\fP"
.br
.RI "Wrapper for the QuatCompress codec, giving it editor capabilities and compatibility/interoperability with the entire \fBTransformCrusher\fP library\&. "
.ti -1c
.RI "class \fBSyncHalfFloatAttribute\fP"
.br
.ti -1c
.RI "class \fBSyncListAttribute\fP"
.br
.ti -1c
.RI "class \fBSyncRangedIntAttribute\fP"
.br
.ti -1c
.RI "class \fBSyncVarAttribute\fP"
.br
.RI "The default packing handler\&. "
.ti -1c
.RI "class \fBTransformCrusher\fP"
.br
.ti -1c
.RI "class \fBWorldBounds\fP"
.br
.RI "Put this object on the root of a game map\&. "
.ti -1c
.RI "class \fBWorldBoundsGroup\fP"
.br
.ti -1c
.RI "class \fBWorldBoundsSelectAttributeAttribute\fP"
.br
.ti -1c
.RI "class \fBWorldBoundsSettings\fP"
.br
.ti -1c
.RI "class \fBXYZSwitchMaskAttribute\fP"
.br
.ti -1c
.RI "class \fBZigZagExt\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBPackedBitsSize\fP { \fBUInt8\fP = 4, \fBUInt16\fP = 5, \fBUInt32\fP = 6, \fBUInt64\fP = 7 }"
.br
.ti -1c
.RI "enum \fBPackedBytesSize\fP { \fBUInt8\fP = 1, \fBUInt16\fP = 2, \fBUInt32\fP = 3, \fBUInt64\fP = 4 }"
.br
.ti -1c
.RI "enum \fBSerializationFlags\fP { \fBNone\fP = 0, \fBHasContent\fP = 1, \fBForce\fP = 2, \fBForceReliable\fP = 4, \fBSendToSelf\fP = 8, \fBNewConnection\fP = 16, \fBIsComplete\fP = 32 }"
.br
.ti -1c
.RI "enum \fBLiteOutOfBoundsHandling\fP { \fBClamp\fP, \fBLoop\fP }"
.br
.ti -1c
.RI "enum \fBLiteFloatCompressType\fP { \fBBits2\fP = 2, \fBBits3\fP, \fBBits4\fP, \fBBits5\fP, \fBBits6\fP, \fBBits7\fP, \fBBits8\fP, \fBBits9\fP, \fBBits10\fP, \fBBits12\fP = 12, \fBBits14\fP = 14, \fBHalf16\fP = 16, \fBFull32\fP = 32 }"
.br
.ti -1c
.RI "enum \fBLiteIntCompressType\fP { \fBPackSigned\fP, \fBPackUnsigned\fP, \fBRange\fP }"
.br
.ti -1c
.RI "enum \fBNormalizedFloatCompression\fP { \fBBits2\fP = 2, \fBBits3\fP, \fBBits4\fP, \fBBits5\fP, \fBBits6\fP, \fBBits7\fP, \fBBits8\fP, \fBBits9\fP, \fBBits10\fP, \fBBits12\fP = 12, \fBBits14\fP = 14, \fBHalf16\fP = 16, \fBFull32\fP = 32 }"
.br
.ti -1c
.RI "enum \fBDefaultKeyRate\fP { \fBNever\fP, \fBEvery\fP, \fBEvery2nd\fP, \fBEvery3rd\fP, \fBEvery4th\fP, \fBEvery5th\fP, \fBEvery10th\fP = 10 }"
.br
.ti -1c
.RI "enum \fBDefaultPackInclusion\fP { \fBExplicit\fP, \fBAllPublic\fP }"
.br
.RI "Indicates what automatically will be Packed\&. "
.ti -1c
.RI "enum \fBKeyRate\fP { \fBUseDefault\fP = -1, \fBNever\fP, \fBEvery\fP, \fBEvery2nd\fP, \fBEvery3rd\fP, \fBEvery4th\fP, \fBEvery5th\fP, \fBEvery10th\fP = 10 }"
.br
.ti -1c
.RI "enum \fBSyncAs\fP { \fBAuto\fP, \fBState\fP, \fBTrigger\fP }"
.br
.RI "Indicates how a [Pack] syncvar acts\&. "
.ti -1c
.RI "enum \fBSetValueTiming\fP { \fBNever\fP, \fBAfterCallback\fP, \fBBeforeCallback\fP }"
.br
.RI "Callbacks assigned to Pack attributes can be called before or after the value is set\&. "
.ti -1c
.RI "enum \fBIndicatorBit\fP { \fBNone\fP, \fBIsZero\fP }"
.br
.RI "This enum indicates if an extra bit should be added to indicate cases of Zero value\&. "
.ti -1c
.RI "enum \fBIndicatorBits\fP { \fBNone\fP, \fBIsZero\fP, \fBIsZeroMidMinMax\fP }"
.br
.RI "This enum indicates if an extra bit should be added to indicate cases of Zero value, XXXXX preValue, or two bits should be added to indicate Zero, Min, Max\&. "
.ti -1c
.RI "enum \fBCompressLevel\fP { \fBSetBits\fP = -1, \fBDisabled\fP = 0, \fBuint16Low\fP = 16, \fBuint32Med\fP = 32, \fBuint64Hi\fP = 64 }"
.br
.ti -1c
.RI "enum \fBIncludedAxes\fP { \fBNone\fP = 0, \fBX\fP = 1, \fBY\fP = 2, \fBXY\fP = 3, \fBZ\fP = 4, \fBXZ\fP = 5, \fBYZ\fP = 6, \fBXYZ\fP = 7, \fBUniform\fP = 15 }"
.br
.ti -1c
.RI "enum \fBFactorBoundsOn\fP { \fBEnableDisable\fP, \fBAwakeDestroy\fP }"
.br
.in -1c
.SH "Detailed Description"
.PP 
Temporariliy using the \fBUtilities\fP namespace to avoid collisions with the DLL still in use by NST 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBPhoton\&.Compression\&.CompressLevel\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISetBits \fP\fP
.TP
\fB\fIDisabled \fP\fP
.TP
\fB\fIuint16Low \fP\fP
.TP
\fB\fIuint32Med \fP\fP
.TP
\fB\fIuint64Hi \fP\fP
.PP
Definition at line \fB18\fP of file \fBQuatCrusher\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.DefaultKeyRate\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINever \fP\fP
.TP
\fB\fIEvery \fP\fP
.TP
\fB\fIEvery2nd \fP\fP
.TP
\fB\fIEvery3rd \fP\fP
.TP
\fB\fIEvery4th \fP\fP
.TP
\fB\fIEvery5th \fP\fP
.TP
\fB\fIEvery10th \fP\fP
.PP
Definition at line \fB10\fP of file \fBPackObjectAttribute\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.DefaultPackInclusion\fP"

.PP
Indicates what automatically will be Packed\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIExplicit \fP\fP
Only fields with a Pack Attribute will be included\&. 
.TP
\fB\fIAllPublic \fP\fP
The default PackAttribute will be applied to all recognized public fields\&. 
.PP
Definition at line \fB19\fP of file \fBPackObjectAttribute\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.FactorBoundsOn\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIEnableDisable \fP\fP
.TP
\fB\fIAwakeDestroy \fP\fP
.PP
Definition at line \fB16\fP of file \fBWorldBounds\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.IncludedAxes\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINone \fP\fP
.TP
\fB\fIX \fP\fP
.TP
\fB\fIY \fP\fP
.TP
\fB\fIXY \fP\fP
.TP
\fB\fIZ \fP\fP
.TP
\fB\fIXZ \fP\fP
.TP
\fB\fIYZ \fP\fP
.TP
\fB\fIXYZ \fP\fP
.TP
\fB\fIUniform \fP\fP
.PP
Definition at line \fB14\fP of file \fBIncludedAxisEnum\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.IndicatorBit\fP"

.PP
This enum indicates if an extra bit should be added to indicate cases of Zero value\&. When value is zero, only the one bit is sent\&. Useful for values that spend more time at zero than not, and delta frames are not an option\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINone \fP\fP
.TP
\fB\fIIsZero \fP\fP
.PP
Definition at line \fB38\fP of file \fBPackObjectEnums\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.IndicatorBits\fP"

.PP
This enum indicates if an extra bit should be added to indicate cases of Zero value, XXXXX preValue, or two bits should be added to indicate Zero, Min, Max\&. When value is one of those, only the indicator bits will be written\&. Use this if these values are expected to spend most of their life at zero, min or max\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINone \fP\fP
.TP
\fB\fIIsZero \fP\fP
.TP
\fB\fIIsZeroMidMinMax \fP\fP
.PP
Definition at line \fB44\fP of file \fBPackObjectEnums\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.KeyRate\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUseDefault \fP\fP
.TP
\fB\fINever \fP\fP
.TP
\fB\fIEvery \fP\fP
.TP
\fB\fIEvery2nd \fP\fP
.TP
\fB\fIEvery3rd \fP\fP
.TP
\fB\fIEvery4th \fP\fP
.TP
\fB\fIEvery5th \fP\fP
.TP
\fB\fIEvery10th \fP\fP
.PP
Definition at line \fB8\fP of file \fBPackObjectEnums\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.LiteFloatCompressType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIBits2 \fP\fP
.TP
\fB\fIBits3 \fP\fP
.TP
\fB\fIBits4 \fP\fP
.TP
\fB\fIBits5 \fP\fP
.TP
\fB\fIBits6 \fP\fP
.TP
\fB\fIBits7 \fP\fP
.TP
\fB\fIBits8 \fP\fP
.TP
\fB\fIBits9 \fP\fP
.TP
\fB\fIBits10 \fP\fP
.TP
\fB\fIBits12 \fP\fP
.TP
\fB\fIBits14 \fP\fP
.TP
\fB\fIHalf16 \fP\fP
.TP
\fB\fIFull32 \fP\fP
.PP
Definition at line \fB12\fP of file \fBLiteFloatCrusher\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.LiteIntCompressType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPackSigned \fP\fP
.TP
\fB\fIPackUnsigned \fP\fP
.TP
\fB\fIRange \fP\fP
.PP
Definition at line \fB11\fP of file \fBLiteIntCrusher\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.LiteOutOfBoundsHandling\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIClamp \fP\fP
.TP
\fB\fILoop \fP\fP
.PP
Definition at line \fB11\fP of file \fBLiteFloatCrusher\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.NormalizedFloatCompression\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIBits2 \fP\fP
.TP
\fB\fIBits3 \fP\fP
.TP
\fB\fIBits4 \fP\fP
.TP
\fB\fIBits5 \fP\fP
.TP
\fB\fIBits6 \fP\fP
.TP
\fB\fIBits7 \fP\fP
.TP
\fB\fIBits8 \fP\fP
.TP
\fB\fIBits9 \fP\fP
.TP
\fB\fIBits10 \fP\fP
.TP
\fB\fIBits12 \fP\fP
.TP
\fB\fIBits14 \fP\fP
.TP
\fB\fIHalf16 \fP\fP
.TP
\fB\fIFull32 \fP\fP
.PP
Definition at line \fB6\fP of file \fBNormCompress\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.PackedBitsSize\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUInt8 \fP\fP
.TP
\fB\fIUInt16 \fP\fP
.TP
\fB\fIUInt32 \fP\fP
.TP
\fB\fIUInt64 \fP\fP
.PP
Definition at line \fB30\fP of file \fBBitCounter\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.PackedBytesSize\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUInt8 \fP\fP
.TP
\fB\fIUInt16 \fP\fP
.TP
\fB\fIUInt32 \fP\fP
.TP
\fB\fIUInt64 \fP\fP
.PP
Definition at line \fB31\fP of file \fBBitCounter\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.SerializationFlags\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINone \fP\fP
.TP
\fB\fIHasContent \fP\fP
.TP
\fB\fIForce \fP\fP
.TP
\fB\fIForceReliable \fP\fP
.TP
\fB\fISendToSelf \fP\fP
.TP
\fB\fINewConnection \fP\fP
.TP
\fB\fIIsComplete \fP\fP
.PP
Definition at line \fB8\fP of file \fBSerializationFlags\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.SetValueTiming\fP"

.PP
Callbacks assigned to Pack attributes can be called before or after the value is set\&. You can also opt for the value not to be automatically set at all, and handle it yourself in the callback; 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINever \fP\fP
.TP
\fB\fIAfterCallback \fP\fP
.TP
\fB\fIBeforeCallback \fP\fP
.PP
Definition at line \fB32\fP of file \fBPackObjectEnums\&.cs\fP\&.
.SS "enum \fBPhoton\&.Compression\&.SyncAs\fP"

.PP
Indicates how a [Pack] syncvar acts\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIAuto \fP\fP
For PackObjects this uses the default of State\&. For Pack syncvar fields this indicates they should use the PackObject setting\&. 
.TP
\fB\fIState \fP\fP
Pack syncvar replicates changes in value to other clients, and stays at that value until changed by the owner\&. 
.TP
\fB\fITrigger \fP\fP
Pack syncvar resets value on owner after its value is captured/sent\&. Reset is done with value = new T()\&. Only works on struct types\&. 
.PP
Definition at line \fB13\fP of file \fBPackObjectEnums\&.cs\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Purrpatrator User manual from the source code\&.
