.TH "Photon.Compression.CompressedElement" 3 "Mon Apr 18 2022" "Purrpatrator User manual" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Photon.Compression.CompressedElement \- The compressed result of crushing\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits IEquatable< CompressedElement >\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBClear\fP ()"
.br
.ti -1c
.RI "ulong[] \fBAsArray64\fP (BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Serializes the \fBCompressedElement\fP into an array\&. "
.ti -1c
.RI "void \fBAsArray64\fP (ulong[] nonalloc, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Serializes the \fBCompressedElement\fP into supplied nonalloc array\&. "
.ti -1c
.RI "uint[] \fBAsArray32\fP (BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Serializes the \fBCompressedElement\fP into an array\&. "
.ti -1c
.RI "void \fBAsArray32\fP (uint[] nonalloc, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Serializes the \fBCompressedElement\fP into supplied nonalloc array\&. "
.ti -1c
.RI "byte[] \fBAsArray8\fP (BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Serializes the \fBCompressedElement\fP into an array\&. "
.ti -1c
.RI "void \fBAsArray8\fP (byte[] nonalloc, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Serializes the \fBCompressedElement\fP into supplied nonalloc array\&. "
.ti -1c
.RI "\fBCompressedElement\fP ()"
.br
.ti -1c
.RI "\fBCompressedElement\fP (\fBElementCrusher\fP \fBcrusher\fP, CompressedFloat \fBcx\fP, CompressedFloat \fBcy\fP, CompressedFloat \fBcz\fP)"
.br
.ti -1c
.RI "\fBCompressedElement\fP (\fBElementCrusher\fP \fBcrusher\fP, uint \fBcx\fP, uint \fBcy\fP, uint \fBcz\fP)"
.br
.ti -1c
.RI "\fBCompressedElement\fP (\fBElementCrusher\fP \fBcrusher\fP, uint \fBcUniform\fP)"
.br
.RI "A uint argument indicates compressed uniform scale\&. "
.ti -1c
.RI "\fBCompressedElement\fP (\fBElementCrusher\fP \fBcrusher\fP, ulong \fBcQuat\fP)"
.br
.RI "A uint argument indicates compressed uniform scale\&. "
.ti -1c
.RI "void \fBSet\fP (\fBElementCrusher\fP \fBcrusher\fP, CompressedFloat \fBcx\fP, CompressedFloat \fBcy\fP, CompressedFloat \fBcz\fP)"
.br
.ti -1c
.RI "void \fBSet\fP (\fBElementCrusher\fP \fBcrusher\fP, uint \fBcx\fP, uint \fBcy\fP, uint \fBcz\fP)"
.br
.ti -1c
.RI "void \fBSet\fP (\fBElementCrusher\fP \fBcrusher\fP, uint \fBcUniform\fP)"
.br
.ti -1c
.RI "void \fBSet\fP (\fBElementCrusher\fP \fBcrusher\fP, ulong \fBcQuat\fP)"
.br
.ti -1c
.RI "void \fBCopyTo\fP (\fBCompressedElement\fP copyTarget)"
.br
.ti -1c
.RI "void \fBCopyFrom\fP (\fBCompressedElement\fP copySource)"
.br
.ti -1c
.RI "uint \fBGetUInt\fP (int axis)"
.br
.ti -1c
.RI "\fBElement\fP \fBDecompress\fP ()"
.br
.ti -1c
.RI "void \fBSerialize\fP (byte[] buffer, ref int bitposition, \fBIncludedAxes\fP ia, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "override string \fBToString\fP ()"
.br
.ti -1c
.RI "override bool \fBEquals\fP (object obj)"
.br
.ti -1c
.RI "bool \fBEquals\fP (\fBCompressedElement\fP other)"
.br
.ti -1c
.RI "override int \fBGetHashCode\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBoperator ulong\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator uint\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator ushort\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator byte\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator ulong[]\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator uint[]\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator byte[]\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator Element\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator Vector3\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static \fBoperator Quaternion\fP (\fBCompressedElement\fP ce)"
.br
.ti -1c
.RI "static bool \fBCompare\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b)"
.br
.RI "Basic compare of the X, Y, Z, and W values\&. "
.ti -1c
.RI "static int \fBHighestDifferentBit\fP (uint a, uint b)"
.br
.RI "Get the bit count of the highest bit that is different between two compressed positions\&. "
.ti -1c
.RI "static void \fBExtrapolate\fP (\fBElementCrusher\fP \fBcrusher\fP, \fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor=2)"
.br
.RI "It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. "
.ti -1c
.RI "static \fBCompressedElement\fP \fBExtrapolate\fP (\fBElementCrusher\fP \fBcrusher\fP, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor=2)"
.br
.RI "summary> It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. "
.ti -1c
.RI "static void \fBExtrapolate\fP (\fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor=2)"
.br
.ti -1c
.RI "static \fBCompressedElement\fP \fBExtrapolate\fP (\fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor=2)"
.br
.ti -1c
.RI "static void \fBExtrapolate\fP (\fBElementCrusher\fP \fBcrusher\fP, \fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount=\&.5f)"
.br
.RI "It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. "
.ti -1c
.RI "static \fBCompressedElement\fP \fBExtrapolate\fP (\fBElementCrusher\fP \fBcrusher\fP, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount=\&.5f)"
.br
.ti -1c
.RI "static void \fBExtrapolate\fP (\fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount=\&.5f)"
.br
.RI "It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. "
.ti -1c
.RI "static \fBCompressedElement\fP \fBExtrapolate\fP (\fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount=\&.5f)"
.br
.ti -1c
.RI "static BitCullingLevel \fBGetGuessableBitCullLevel\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b, BitCullingLevel maxCullLvl)"
.br
.RI "Test changes between two compressed Vector3 elements and returns the ideal BitCullingLevel for that change, with the assumption that it will be recreated using best guess (process where the upperbits are incremented and deincremented until the closest position to compare positon is returned\&. "
.ti -1c
.RI "static BitCullingLevel \fBGetGuessableBitCullLevel\fP (\fBCompressedElement\fP oldComp, \fBCompressedElement\fP newComp, \fBElementCrusher\fP ec, BitCullingLevel maxCullLvl)"
.br
.ti -1c
.RI "static BitCullingLevel \fBFindBestBitCullLevel\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b, BitCullingLevel maxCulling)"
.br
.RI "Return the smallest bit culling level that will be able to communicate the changes between two compressed elements\&. "
.ti -1c
.RI "static BitCullingLevel \fBFindBestBitCullLevel\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b, \fBElementCrusher\fP ec, BitCullingLevel maxCulling)"
.br
.ti -1c
.RI "static BitCullingLevel \fBFindBestBitCullLevel\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b, FloatCrusher[] ec, BitCullingLevel maxCulling)"
.br
.ti -1c
.RI "static bool \fBTestMatchingUpper\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b, BitCullingLevel bcl)"
.br
.ti -1c
.RI "static bool \fBTestMatchingUpper\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b, \fBElementCrusher\fP ec, BitCullingLevel bcl)"
.br
.ti -1c
.RI "static bool \fBTestMatchingUpper\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b, FloatCrusher[] ec, BitCullingLevel bcl)"
.br
.ti -1c
.RI "static bool \fBoperator==\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b)"
.br
.ti -1c
.RI "static bool \fBoperator!=\fP (\fBCompressedElement\fP a, \fBCompressedElement\fP b)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "CompressedFloat \fBcx\fP"
.br
.ti -1c
.RI "CompressedFloat \fBcy\fP"
.br
.ti -1c
.RI "CompressedFloat \fBcz\fP"
.br
.ti -1c
.RI "CompressedFloat \fBcUniform\fP"
.br
.ti -1c
.RI "\fBCompressedQuat\fP \fBcQuat\fP"
.br
.ti -1c
.RI "\fBElementCrusher\fP \fBcrusher\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static \fBCompressedElement\fP \fBreusable\fP = new \fBCompressedElement\fP()"
.br
.ti -1c
.RI "static readonly \fBCompressedElement\fP \fBEmpty\fP = new \fBCompressedElement\fP()"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "uint?? \fBthis[int axis]\fP\fC [get]\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The compressed result of crushing\&. 

Contains the individual float/quat crusher results involved\&. 
.PP
Definition at line \fB19\fP of file \fBCompressedElement\&.cs\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Photon\&.Compression\&.CompressedElement\&.CompressedElement ()"

.PP
Definition at line \fB263\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "Photon\&.Compression\&.CompressedElement\&.CompressedElement (\fBElementCrusher\fP crusher, CompressedFloat cx, CompressedFloat cy, CompressedFloat cz)"

.PP
Definition at line \fB268\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "Photon\&.Compression\&.CompressedElement\&.CompressedElement (\fBElementCrusher\fP crusher, uint cx, uint cy, uint cz)"

.PP
Definition at line \fB278\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "Photon\&.Compression\&.CompressedElement\&.CompressedElement (\fBElementCrusher\fP crusher, uint cUniform)"

.PP
A uint argument indicates compressed uniform scale\&. A ulong argument indicates a compressed quaternion\&. Be sure to cast ulongs down to uint, or your scale we be treated as quaternion values for this constructor\&. 
.PP
\fBParameters\fP
.RS 4
\fIcrusher\fP 
.br
\fIcUniform\fP 
.br
\fIubits\fP 
.RE
.PP

.PP
Definition at line \fB295\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "Photon\&.Compression\&.CompressedElement\&.CompressedElement (\fBElementCrusher\fP crusher, ulong cQuat)"

.PP
A uint argument indicates compressed uniform scale\&. A ulong argument indicates a compressed quaternion\&. 
.PP
\fBParameters\fP
.RS 4
\fIcrusher\fP 
.br
\fIcQuat\fP 
.br
\fIqbits\fP 
.RE
.PP

.PP
Definition at line \fB309\fP of file \fBCompressedElement\&.cs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "uint[] Photon\&.Compression\&.CompressedElement\&.AsArray32 (BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Serializes the \fBCompressedElement\fP into an array\&. WARNING: The returned array is recycled - so the values are subject to change\&. Use contents immediately\&.
.PP
If you want to store the returned value, supply a nonalloc array as an argument\&.
.PP
Definition at line \fB91\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.AsArray32 (uint[] nonalloc, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Serializes the \fBCompressedElement\fP into supplied nonalloc array\&. NOTE: Contents of the nonalloc array will be overwritten\&.
.PP
Definition at line \fB105\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "ulong[] Photon\&.Compression\&.CompressedElement\&.AsArray64 (BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Serializes the \fBCompressedElement\fP into an array\&. WARNING: The returned array is recycled - so the values are subject to change\&. Use contents immediately\&.
.PP
If you want to store the returned value, supply a nonalloc array as an argument\&.
.PP
Definition at line \fB62\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.AsArray64 (ulong[] nonalloc, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Serializes the \fBCompressedElement\fP into supplied nonalloc array\&. NOTE: Contents of the nonalloc array will be overwritten\&.
.PP
Definition at line \fB76\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "byte[] Photon\&.Compression\&.CompressedElement\&.AsArray8 (BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Serializes the \fBCompressedElement\fP into an array\&. WARNING: The returned array is recycled - so the values are subject to change\&. Use contents immediately\&.
.PP
If you want to store the returned value, supply a nonalloc array as an argument\&.
.PP
Definition at line \fB120\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.AsArray8 (byte[] nonalloc, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Serializes the \fBCompressedElement\fP into supplied nonalloc array\&. NOTE: Contents of the nonalloc array will be overwritten\&.
.PP
Definition at line \fB134\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.Clear ()"

.PP
Definition at line \fB43\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.CompressedElement\&.Compare (\fBCompressedElement\fP a, \fBCompressedElement\fP b)\fC [static]\fP"

.PP
Basic compare of the X, Y, Z, and W values\&. True if they all match\&. 
.PP
Definition at line \fB391\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.CopyFrom (\fBCompressedElement\fP copySource)"

.PP
Definition at line \fB354\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.CopyTo (\fBCompressedElement\fP copyTarget)"

.PP
Definition at line \fB347\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "\fBElement\fP Photon\&.Compression\&.CompressedElement\&.Decompress ()"

.PP
Definition at line \fB377\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "bool Photon\&.Compression\&.CompressedElement\&.Equals (\fBCompressedElement\fP other)"

.PP
Definition at line \fB732\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "override bool Photon\&.Compression\&.CompressedElement\&.Equals (object obj)"

.PP
Definition at line \fB727\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static \fBCompressedElement\fP Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount = \fC\&.5f\fP)\fC [static]\fP"

.PP
Definition at line \fB524\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static \fBCompressedElement\fP Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor = \fC2\fP)\fC [static]\fP"

.PP
Definition at line \fB469\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static void Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount = \fC\&.5f\fP)\fC [static]\fP"

.PP
It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. 
.PP
Definition at line \fB511\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static void Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor = \fC2\fP)\fC [static]\fP"

.PP
Definition at line \fB458\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static \fBCompressedElement\fP Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBElementCrusher\fP crusher, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount = \fC\&.5f\fP)\fC [static]\fP"

.PP
Definition at line \fB496\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static \fBCompressedElement\fP Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBElementCrusher\fP crusher, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor = \fC2\fP)\fC [static]\fP"

.PP
summary> It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. Uses curr\&.crusher\&. 
.PP
Definition at line \fB444\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static void Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBElementCrusher\fP crusher, \fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, float amount = \fC\&.5f\fP)\fC [static]\fP"

.PP
It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. 
.PP
Definition at line \fB483\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static void Photon\&.Compression\&.CompressedElement\&.Extrapolate (\fBElementCrusher\fP crusher, \fBCompressedElement\fP target, \fBCompressedElement\fP curr, \fBCompressedElement\fP prev, int divisor = \fC2\fP)\fC [static]\fP"

.PP
It may preferable to use the overload that takes and int divisor value than a float, to avoid all float math to possibly reduce jitter\&. 
.PP
Definition at line \fB433\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static BitCullingLevel Photon\&.Compression\&.CompressedElement\&.FindBestBitCullLevel (\fBCompressedElement\fP a, \fBCompressedElement\fP b, BitCullingLevel maxCulling)\fC [static]\fP"

.PP
Return the smallest bit culling level that will be able to communicate the changes between two compressed elements\&. Quats can't cull upper bits, so its an all or nothing\&. Either the bits match or they don't
.PP
Definition at line \fB582\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static BitCullingLevel Photon\&.Compression\&.CompressedElement\&.FindBestBitCullLevel (\fBCompressedElement\fP a, \fBCompressedElement\fP b, \fBElementCrusher\fP ec, BitCullingLevel maxCulling)\fC [static]\fP"
Quats can't cull upper bits, so its an all or nothing\&. Either the bits match or they don't
.PP
Definition at line \fB613\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static BitCullingLevel Photon\&.Compression\&.CompressedElement\&.FindBestBitCullLevel (\fBCompressedElement\fP a, \fBCompressedElement\fP b, FloatCrusher[] ec, BitCullingLevel maxCulling)\fC [static]\fP"

.PP
Definition at line \fB637\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static BitCullingLevel Photon\&.Compression\&.CompressedElement\&.GetGuessableBitCullLevel (\fBCompressedElement\fP a, \fBCompressedElement\fP b, BitCullingLevel maxCullLvl)\fC [static]\fP"

.PP
Test changes between two compressed Vector3 elements and returns the ideal BitCullingLevel for that change, with the assumption that it will be recreated using best guess (process where the upperbits are incremented and deincremented until the closest position to compare positon is returned\&. NOT FULLY TESTED 
.PP
\fBParameters\fP
.RS 4
\fIa\fP 
.br
\fIb\fP 
.br
\fImaxCullLvl\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB549\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static BitCullingLevel Photon\&.Compression\&.CompressedElement\&.GetGuessableBitCullLevel (\fBCompressedElement\fP oldComp, \fBCompressedElement\fP newComp, \fBElementCrusher\fP ec, BitCullingLevel maxCullLvl)\fC [static]\fP"

.PP
Definition at line \fB564\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "override int Photon\&.Compression\&.CompressedElement\&.GetHashCode ()"

.PP
Definition at line \fB746\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "uint Photon\&.Compression\&.CompressedElement\&.GetUInt (int axis)"

.PP
Definition at line \fB372\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static int Photon\&.Compression\&.CompressedElement\&.HighestDifferentBit (uint a, uint b)\fC [static]\fP"

.PP
Get the bit count of the highest bit that is different between two compressed positions\&. This is the min number of bits that must be sent\&. 
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB400\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator byte (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB180\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator byte[] (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB203\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator \fBElement\fP (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB209\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator Quaternion (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB230\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator uint (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB158\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator uint[] (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB197\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator ulong (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB147\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator ulong[] (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB191\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator ushort (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB169\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static Photon\&.Compression\&.CompressedElement\&.operator Vector3 (\fBCompressedElement\fP ce)\fC [explicit]\fP, \fC [static]\fP"

.PP
Definition at line \fB214\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.CompressedElement\&.operator!= (\fBCompressedElement\fP a, \fBCompressedElement\fP b)\fC [static]\fP"

.PP
Definition at line \fB718\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.CompressedElement\&.operator== (\fBCompressedElement\fP a, \fBCompressedElement\fP b)\fC [static]\fP"

.PP
Definition at line \fB711\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.Serialize (byte[] buffer, ref int bitposition, \fBIncludedAxes\fP ia, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB382\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.Set (\fBElementCrusher\fP crusher, CompressedFloat cx, CompressedFloat cy, CompressedFloat cz)"

.PP
Definition at line \fB320\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.Set (\fBElementCrusher\fP crusher, uint cUniform)"

.PP
Definition at line \fB334\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.Set (\fBElementCrusher\fP crusher, uint cx, uint cy, uint cz)"

.PP
Definition at line \fB327\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "void Photon\&.Compression\&.CompressedElement\&.Set (\fBElementCrusher\fP crusher, ulong cQuat)"

.PP
Definition at line \fB339\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.CompressedElement\&.TestMatchingUpper (\fBCompressedElement\fP a, \fBCompressedElement\fP b, BitCullingLevel bcl)\fC [static]\fP"

.PP
Definition at line \fB656\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.CompressedElement\&.TestMatchingUpper (\fBCompressedElement\fP a, \fBCompressedElement\fP b, \fBElementCrusher\fP ec, BitCullingLevel bcl)\fC [static]\fP"

.PP
Definition at line \fB667\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.CompressedElement\&.TestMatchingUpper (\fBCompressedElement\fP a, \fBCompressedElement\fP b, FloatCrusher[] ec, BitCullingLevel bcl)\fC [static]\fP"

.PP
Definition at line \fB677\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "override string Photon\&.Compression\&.CompressedElement\&.ToString ()"

.PP
Definition at line \fB696\fP of file \fBCompressedElement\&.cs\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBCompressedQuat\fP Photon\&.Compression\&.CompressedElement\&.cQuat"

.PP
Definition at line \fB36\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "\fBElementCrusher\fP Photon\&.Compression\&.CompressedElement\&.crusher"

.PP
Definition at line \fB39\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "CompressedFloat Photon\&.Compression\&.CompressedElement\&.cUniform"

.PP
Definition at line \fB33\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "CompressedFloat Photon\&.Compression\&.CompressedElement\&.cx"

.PP
Definition at line \fB26\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "CompressedFloat Photon\&.Compression\&.CompressedElement\&.cy"

.PP
Definition at line \fB28\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "CompressedFloat Photon\&.Compression\&.CompressedElement\&.cz"

.PP
Definition at line \fB30\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "readonly \fBCompressedElement\fP Photon\&.Compression\&.CompressedElement\&.Empty = new \fBCompressedElement\fP()\fC [static]\fP"

.PP
Definition at line \fB261\fP of file \fBCompressedElement\&.cs\fP\&.
.SS "\fBCompressedElement\fP Photon\&.Compression\&.CompressedElement\&.reusable = new \fBCompressedElement\fP()\fC [static]\fP"

.PP
Definition at line \fB23\fP of file \fBCompressedElement\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "uint?? Photon\&.Compression\&.CompressedElement\&.this[int axis]\fC [get]\fP"

.PP
Definition at line \fB364\fP of file \fBCompressedElement\&.cs\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Purrpatrator User manual from the source code\&.
