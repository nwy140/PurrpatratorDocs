.TH "Photon.Compression.TransformCrusher" 3 "Mon Apr 18 2022" "Purrpatrator User manual" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Photon.Compression.TransformCrusher
.SH SYNOPSIS
.br
.PP
.PP
Inherits Crusher< TransformCrusher >, and ICrusherCopy< TransformCrusher >\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBOnCrusherChange\fP (\fBElementCrusher\fP crusher)"
.br
.RI "Callback fired whenever a component \fBElementCrusher\fP is changed\&. "
.ti -1c
.RI "\fBTransformCrusher\fP ()"
.br
.ti -1c
.RI "\fBTransformCrusher\fP (bool isStatic=false)"
.br
.RI "Default constructor for \fBTransformCrusher\fP\&. "
.ti -1c
.RI "override void \fBOnBeforeSerialize\fP ()"
.br
.ti -1c
.RI "override void \fBOnAfterDeserialize\fP ()"
.br
.ti -1c
.RI "virtual void \fBCacheValues\fP ()"
.br
.ti -1c
.RI "void \fBWrite\fP (\fBCompressedMatrix\fP cm, byte[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBWrite\fP (\fBCompressedMatrix\fP cm, uint[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBWrite\fP (\fBCompressedMatrix\fP cm, ulong[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBWrite\fP (\fBCompressedMatrix\fP nonalloc, Transform transform, byte[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBWrite\fP (Transform transform, byte[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (ulong[] array, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (uint[] array, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (byte[] array, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBReadAndDecompress\fP (\fBMatrix\fP nonalloc, ulong[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBReadAndDecompress\fP (\fBMatrix\fP nonalloc, uint[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBReadAndDecompress\fP (\fBMatrix\fP nonalloc, byte[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (ulong[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (uint[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (byte[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBRead\fP (\fBCompressedMatrix\fP nonalloc, byte[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (ulong[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (uint[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (byte[] array, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (ulong[] array, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (uint[] array, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (byte[] array, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBRead\fP (\fBCompressedMatrix\fP nonalloc, ulong[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBRead\fP (\fBCompressedMatrix\fP nonalloc, uint[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBWrite\fP (\fBCompressedMatrix\fP nonalloc, Transform transform, ref ulong buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Compress a transform using this crusher, store the compressed results in a supplied \fBCompressedMatrix\fP, and serialize the compressed values to the buffer\&. "
.ti -1c
.RI "void \fBWrite\fP (Transform transform, ref ulong buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Compress and write all of the components of transform, without creating any intermediary \fBCompressedMatrix\fP or Bitstream\&. "
.ti -1c
.RI "void \fBWrite\fP (\fBCompressedMatrix\fP cm, ref ulong buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Serialize a \fBCompressedMatrix\fP to a bitstream\&. "
.ti -1c
.RI "void \fBWrite\fP (\fBCompressedMatrix\fP nonalloc, Transform transform, ref ulong bitstream, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Compress a transform using this crusher, store the compressed results in a supplied \fBCompressedMatrix\fP, and serialize the compressed values to the bitstream\&. "
.ti -1c
.RI "void \fBReadAndDecompress\fP (\fBMatrix\fP nonalloc, ulong buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (ulong buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBReadAndDecompress\fP (\fBMatrix\fP nonalloc, ulong buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBReadAndDecompress\fP (ulong buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBReadAndApply\fP (Transform target, byte[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Read the compressed value from a buffer, decompress it, and apply it to the target transform\&. "
.ti -1c
.RI "void \fBRead\fP (\fBCompressedMatrix\fP nonalloc, ulong frag0, ulong frag1=0, ulong frag2=0, ulong frag3=0, ulong frag4=0, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Reconstruct a \fBCompressedMatrix\fP from fragments\&. "
.ti -1c
.RI "void \fBReadAndDecompress\fP (\fBMatrix\fP nonalloc, ulong frag0, ulong frag1=0, ulong frag2=0, ulong frag3=0, ulong frag4=0, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (ulong frag0, ulong frag1=0, ulong frag2=0, ulong frag3=0, uint frag4=0, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBRead\fP (\fBCompressedMatrix\fP nonalloc, ulong buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Extract a \fBCompressedMatrix\fP from a primitive buffer\&. "
.ti -1c
.RI "void \fBRead\fP (\fBCompressedMatrix\fP nonalloc, ulong buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Extract a \fBCompressedMatrix\fP from a primitive buffer\&. "
.ti -1c
.RI "\fBCompressedMatrix\fP \fBRead\fP (ulong buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBCompress\fP (\fBCompressedMatrix\fP nonalloc)"
.br
.RI "Compress the transform of the default gameobject\&. "
.ti -1c
.RI "\fBCompressedMatrix\fP \fBCompress\fP ()"
.br
.ti -1c
.RI "void \fBCompress\fP (\fBCompressedMatrix\fP nonalloc, \fBMatrix\fP matrix)"
.br
.ti -1c
.RI "void \fBCompress\fP (\fBCompressedMatrix\fP nonalloc, Transform transform)"
.br
.ti -1c
.RI "\fBCompressedMatrix\fP \fBCompress\fP (Transform transform)"
.br
.RI "Compressed to an internally reused \fBCompressedMatrix\fP\&. "
.ti -1c
.RI "\fBCompressedMatrix\fP \fBCompress\fP (Rigidbody rb)"
.br
.RI "Compress Rigodbody to an internally reused \fBCompressedMatrix\fP\&. "
.ti -1c
.RI "void \fBCompress\fP (\fBCompressedMatrix\fP nonalloc, Rigidbody rb)"
.br
.RI "Compress to Rigidbody to supplied \fBCompressedMatrix\fP\&. "
.ti -1c
.RI "\fBCompressedMatrix\fP \fBCompress\fP (Rigidbody2D rb2d)"
.br
.RI "Compressed Rigidbody2D to an internally reused \fBCompressedMatrix\fP\&. "
.ti -1c
.RI "void \fBCompress\fP (\fBCompressedMatrix\fP nonalloc, Rigidbody2D rb2d)"
.br
.RI "Compress to Rigidbody2D to supplied \fBCompressedMatrix\fP\&. "
.ti -1c
.RI "void \fBCompressAndWrite\fP (\fBMatrix\fP matrix, byte[] buffer, ref int bitposition)"
.br
.RI "CompressAndWrite doesn't produce any temporary 40byte bitstream structs, but rather will compress and write directly to the supplied bitstream\&. "
.ti -1c
.RI "void \fBCompressAndWrite\fP (Transform transform, byte[] buffer, ref int bitposition)"
.br
.RI "CompressAndWrite doesn't produce any temporary 40byte bitstream structs, but rather will compress and write directly to the supplied bitstream\&. "
.ti -1c
.RI "void \fBCompressAndWrite\fP (Rigidbody rb, byte[] buffer, ref int bitposition)"
.br
.RI "CompressAndWrite doesn't produce any temporary 40byte bitstream structs, but rather will compress and write directly to the supplied bitstream\&. "
.ti -1c
.RI "void \fBDecompress\fP (\fBMatrix\fP nonalloc, ulong[] buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBDecompress\fP (\fBMatrix\fP nonalloc, uint[] buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBDecompress\fP (\fBMatrix\fP nonalloc, ulong compressed, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBDecompress\fP (ulong[] buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBDecompress\fP (uint[] buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBDecompress\fP (byte[] buffer, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBDecompress\fP (ulong compressed, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.ti -1c
.RI "void \fBDecompress\fP (\fBMatrix\fP nonalloc, \fBCompressedMatrix\fP compMatrix)"
.br
.ti -1c
.RI "\fBMatrix\fP \fBDecompress\fP (\fBCompressedMatrix\fP compMatrix)"
.br
.ti -1c
.RI "void \fBSet\fP (Rigidbody rb, \fBCompressedMatrix\fP cmatrix)"
.br
.RI "Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. "
.ti -1c
.RI "void \fBSet\fP (Rigidbody rb, \fBMatrix\fP matrix)"
.br
.RI "Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. "
.ti -1c
.RI "void \fBSet\fP (Rigidbody rb, ulong frag0, ulong frag1=0, ulong frag2=0, ulong frag3=0, ulong frag4=0)"
.br
.RI "Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. "
.ti -1c
.RI "void \fBSet\fP (Rigidbody rb, ulong[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. "
.ti -1c
.RI "void \fBSet\fP (Rigidbody rb, byte[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. "
.ti -1c
.RI "void \fBSet\fP (Rigidbody2D rb2d, \fBMatrix\fP matrix)"
.br
.ti -1c
.RI "void \fBSet\fP (Rigidbody2D rb2d, \fBCompressedMatrix\fP cmatrix)"
.br
.RI "Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. "
.ti -1c
.RI "void \fBMove\fP (Rigidbody rb, \fBCompressedMatrix\fP cmatrix)"
.br
.RI "Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. "
.ti -1c
.RI "void \fBMove\fP (Rigidbody rb, \fBMatrix\fP matrix)"
.br
.RI "Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. "
.ti -1c
.RI "void \fBMove\fP (Rigidbody rb, ulong frag0, ulong frag1=0, ulong frag2=0, ulong frag3=0, ulong frag4=0)"
.br
.RI "Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. "
.ti -1c
.RI "void \fBMove\fP (Rigidbody rb, ulong[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. "
.ti -1c
.RI "void \fBMove\fP (Rigidbody rb, byte[] buffer, ref int bitposition, BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. "
.ti -1c
.RI "void \fBApply\fP (Rigidbody rb, \fBCompressedMatrix\fP cmatrix)"
.br
.RI "Apply the \fBCompressedMatrix\fP to a Rigidbody\&. "
.ti -1c
.RI "void \fBApply\fP (Rigidbody rb, \fBMatrix\fP matrix)"
.br
.RI "Apply the TRS matrix to a transform\&. "
.ti -1c
.RI "void \fBApply\fP (ulong cvalue)"
.br
.ti -1c
.RI "void \fBApply\fP (Transform t, ulong cvalue)"
.br
.ti -1c
.RI "void \fBApply\fP (ulong u0, ulong u1, ulong u2, ulong u3, uint u4)"
.br
.ti -1c
.RI "void \fBApply\fP (Transform t, ulong frag0, ulong frag1=0, ulong frag2=0, ulong frag3=0, ulong frag4=0)"
.br
.ti -1c
.RI "void \fBApply\fP (\fBCompressedMatrix\fP cmatrix)"
.br
.RI "Apply the \fBCompressedMatrix\fP to a transform\&. "
.ti -1c
.RI "void \fBApply\fP (Transform t, \fBCompressedMatrix\fP cmatrix)"
.br
.RI "Apply the \fBCompressedMatrix\fP to a transform\&. "
.ti -1c
.RI "void \fBApply\fP (\fBMatrix\fP matrix)"
.br
.RI "Apply the TRS matrix to a transform\&. "
.ti -1c
.RI "void \fBApply\fP (Transform transform, \fBMatrix\fP matrix)"
.br
.RI "Apply the TRS matrix to a transform\&. "
.ti -1c
.RI "void \fBCapture\fP (Rigidbody rb, \fBCompressedMatrix\fP cm, \fBMatrix\fP m)"
.br
.RI "Capture the values of a Rigidbody\&. "
.ti -1c
.RI "void \fBCapture\fP (Rigidbody2D rb2d, \fBCompressedMatrix\fP cm, \fBMatrix\fP m)"
.br
.RI "Capture the values of a Rigidbody2d\&. "
.ti -1c
.RI "void \fBCapture\fP (Transform tr, \fBCompressedMatrix\fP cm, \fBMatrix\fP m)"
.br
.RI "Capture the values of a Transform\&. "
.ti -1c
.RI "int \fBTallyBits\fP (BitCullingLevel bcl=BitCullingLevel\&.NoCulling)"
.br
.RI "Get the total number of bits this Transform is set to write\&. "
.ti -1c
.RI "void \fBCopyFrom\fP (\fBTransformCrusher\fP source)"
.br
.ti -1c
.RI "override bool \fBEquals\fP (object obj)"
.br
.ti -1c
.RI "bool \fBEquals\fP (\fBTransformCrusher\fP other)"
.br
.ti -1c
.RI "override int \fBGetHashCode\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBTransformCrusher\fP \fBCheckAgainstStatics\fP (\fBTransformCrusher\fP tc, bool CheckElementCrusherAsWell=true)"
.br
.RI "See if a crusher with these exact settings exists in the static crushers list\&. "
.ti -1c
.RI "static bool \fBoperator==\fP (\fBTransformCrusher\fP crusher1, \fBTransformCrusher\fP crusher2)"
.br
.ti -1c
.RI "static bool \fBoperator!=\fP (\fBTransformCrusher\fP crusher1, \fBTransformCrusher\fP crusher2)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "Transform \fBdefaultTransform\fP"
.br
.ti -1c
.RI "ReadOnlyCollection< int > \fBcached_total\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "const int \fBVersionMajor\fP = 3"
.br
.ti -1c
.RI "const int \fBVersionMinor\fP = 5"
.br
.ti -1c
.RI "const int \fBVersionRevision\fP = 3"
.br
.ti -1c
.RI "const int \fBBuild\fP = 3503"
.br
.ti -1c
.RI "static Dictionary< int, \fBTransformCrusher\fP > \fBstaticTransformCrushers\fP = new Dictionary<int, \fBTransformCrusher\fP>()"
.br
.ti -1c
.RI "static ulong[] \fBreusableArray64\fP = new ulong[5]"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBConstructDefault\fP (bool isStatic=false)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBElementCrusher\fP \fBposCrusher\fP"
.br
.ti -1c
.RI "\fBElementCrusher\fP \fBrotCrusher\fP"
.br
.ti -1c
.RI "\fBElementCrusher\fP \fBsclCrusher\fP"
.br
.ti -1c
.RI "readonly int[] \fBcached_pBits\fP = new int[4]"
.br
.RI "Temporary \fBCompressedMatrix\fP used internally when a non-alloc is not provided and no return CM or M is required\&. "
.ti -1c
.RI "readonly int[] \fBcached_rBits\fP = new int[4]"
.br
.ti -1c
.RI "readonly int[] \fBcached_sBits\fP = new int[4]"
.br
.ti -1c
.RI "readonly int[] \fB_cached_total\fP = new int[4]"
.br
.ti -1c
.RI "bool \fBcached\fP"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "\fBElementCrusher\fP \fBPosCrusher\fP\fC [getset]\fP"
.br
.RI "Sets the position crusher to the assigned reference, and reruns \fBCacheValues()\fP\&. "
.ti -1c
.RI "\fBElementCrusher\fP \fBRotCrusher\fP\fC [getset]\fP"
.br
.RI "Sets the scale crusher to the assigned reference, and reruns \fBCacheValues()\fP\&. "
.ti -1c
.RI "\fBElementCrusher\fP \fBSclCrusher\fP\fC [getset]\fP"
.br
.RI "Sets the scale crusher to the assigned reference, and reruns \fBCacheValues()\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB23\fP of file \fBTransformCrusher\&.cs\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Photon\&.Compression\&.TransformCrusher\&.TransformCrusher ()"

.PP
Definition at line \fB153\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "Photon\&.Compression\&.TransformCrusher\&.TransformCrusher (bool isStatic = \fCfalse\fP)"

.PP
Default constructor for \fBTransformCrusher\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIisStatic\fP Set this as true if this crusher is not meant to be serialized\&. Static crushers are created in code, and are not meant to be modified after creation\&. This allows them to be indexed by their hashcodes and reused\&. 
.RE
.PP

.PP
Definition at line \fB163\fP of file \fBTransformCrusher\&.cs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (\fBCompressedMatrix\fP cmatrix)"

.PP
Apply the \fBCompressedMatrix\fP to a transform\&. Any axes not included in the Crusher are left as is\&. 
.PP
Definition at line \fB1157\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (\fBMatrix\fP matrix)"

.PP
Apply the TRS matrix to a transform\&. Any axes not included in the Crusher are left as is\&. 
.PP
Definition at line \fB1182\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (Rigidbody rb, \fBCompressedMatrix\fP cmatrix)"

.PP
Apply the \fBCompressedMatrix\fP to a Rigidbody\&. Any axes not included in the Crusher are left as is\&. 
.PP
Definition at line \fB1094\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (Rigidbody rb, \fBMatrix\fP matrix)"

.PP
Apply the TRS matrix to a transform\&. Any axes not included in the Crusher are left as is\&. 
.PP
Definition at line \fB1108\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (Transform t, \fBCompressedMatrix\fP cmatrix)"

.PP
Apply the \fBCompressedMatrix\fP to a transform\&. Any axes not included in the Crusher are left as is\&. 
.PP
Definition at line \fB1167\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (Transform t, ulong cvalue)"

.PP
Definition at line \fB1133\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (Transform t, ulong frag0, ulong frag1 = \fC0\fP, ulong frag2 = \fC0\fP, ulong frag3 = \fC0\fP, ulong frag4 = \fC0\fP)"

.PP
Definition at line \fB1147\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (Transform transform, \fBMatrix\fP matrix)"

.PP
Apply the TRS matrix to a transform\&. Any axes not included in the Crusher are left as is\&. 
.PP
Definition at line \fB1192\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (ulong cvalue)"

.PP
Definition at line \fB1126\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Apply (ulong u0, ulong u1, ulong u2, ulong u3, uint u4)"

.PP
Definition at line \fB1140\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "virtual void Photon\&.Compression\&.TransformCrusher\&.CacheValues ()\fC [virtual]\fP"

.PP
Definition at line \fB223\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Capture (Rigidbody rb, \fBCompressedMatrix\fP cm, \fBMatrix\fP m)"

.PP
Capture the values of a Rigidbody\&. Applies the lossy decompressed value to the \fBMatrix\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIm\fP Lossy decompressed value is stored\&.
.RE
.PP

.PP
Definition at line \fB1208\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Capture (Rigidbody2D rb2d, \fBCompressedMatrix\fP cm, \fBMatrix\fP m)"

.PP
Capture the values of a Rigidbody2d\&. Applies the lossy decompressed value to the \fBMatrix\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIm\fP Lossy decompressed value is stored\&.
.RE
.PP

.PP
Definition at line \fB1218\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Capture (Transform tr, \fBCompressedMatrix\fP cm, \fBMatrix\fP m)"

.PP
Capture the values of a Transform\&. 
.PP
\fBParameters\fP
.RS 4
\fIm\fP Lossy decompressed value is stored\&.
.RE
.PP

.PP
Definition at line \fB1228\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "static \fBTransformCrusher\fP Photon\&.Compression\&.TransformCrusher\&.CheckAgainstStatics (\fBTransformCrusher\fP tc, bool CheckElementCrusherAsWell = \fCtrue\fP)\fC [static]\fP"

.PP
See if a crusher with these exact settings exists in the static crushers list\&. If so, return that already cataloged crusher\&. You may allow the crusher given as an argument be garbage collected\&. NOTE: Any changes to static crushers will break things\&. Currently there are no safeguards against this\&. 
.PP
\fBParameters\fP
.RS 4
\fItc\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB41\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Compress ()"

.PP
Definition at line \fB685\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Compress (\fBCompressedMatrix\fP nonalloc)"

.PP
Compress the transform of the default gameobject\&. (Only avavilable if this crusher is serialized in the editor)\&. 
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB678\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Compress (\fBCompressedMatrix\fP nonalloc, \fBMatrix\fP matrix)"

.PP
Definition at line \fB692\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Compress (\fBCompressedMatrix\fP nonalloc, Rigidbody rb)"

.PP
Compress to Rigidbody to supplied \fBCompressedMatrix\fP\&. 
.PP
Definition at line \fB743\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Compress (\fBCompressedMatrix\fP nonalloc, Rigidbody2D rb2d)"

.PP
Compress to Rigidbody2D to supplied \fBCompressedMatrix\fP\&. NOT FULLY TEST (OR TESTED AT ALL EVEN) TODO: this currently is not using the RB like the 3d version does\&.
.PP
Definition at line \fB769\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Compress (\fBCompressedMatrix\fP nonalloc, Transform transform)"

.PP
Definition at line \fB704\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Compress (Rigidbody rb)"

.PP
Compress Rigodbody to an internally reused \fBCompressedMatrix\fP\&. WARNING: Be sure to use the contents of this \fBCompressedMatrix\fP immediately, as its values will be overwritten often\&. If you need to hold these values, use the nonalloc overload and supply a \fBCompressedMatrix\fP\&. 
.PP
Definition at line \fB734\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Compress (Rigidbody2D rb2d)"

.PP
Compressed Rigidbody2D to an internally reused \fBCompressedMatrix\fP\&. WARNING: Be sure to use the contents of this \fBCompressedMatrix\fP immediately, as its values will be overwritten often\&. If you need to hold these values, use the nonalloc overload and supply a \fBCompressedMatrix\fP\&. 
.PP
Definition at line \fB759\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Compress (Transform transform)"

.PP
Compressed to an internally reused \fBCompressedMatrix\fP\&. WARNING: Be sure to use the contents of this \fBCompressedMatrix\fP immediately, as its values will be overwritten often\&. If you need to hold these values, use the nonalloc overload and supply a \fBCompressedMatrix\fP\&. 
.PP
Definition at line \fB722\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.CompressAndWrite (\fBMatrix\fP matrix, byte[] buffer, ref int bitposition)"

.PP
CompressAndWrite doesn't produce any temporary 40byte bitstream structs, but rather will compress and write directly to the supplied bitstream\&. Use this rather than \fBWrite()\fP and \fBCompress()\fP when you don't need the lossy or compressed value returned\&. 
.PP
\fBParameters\fP
.RS 4
\fImatrix\fP 
.br
\fIbitstream\fP 
.RE
.PP

.PP
Definition at line \fB814\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.CompressAndWrite (Rigidbody rb, byte[] buffer, ref int bitposition)"

.PP
CompressAndWrite doesn't produce any temporary 40byte bitstream structs, but rather will compress and write directly to the supplied bitstream\&. Use this rather than \fBWrite()\fP and \fBCompress()\fP when you don't need the lossy or compressed value returned\&. 
.PP
Definition at line \fB850\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.CompressAndWrite (Transform transform, byte[] buffer, ref int bitposition)"

.PP
CompressAndWrite doesn't produce any temporary 40byte bitstream structs, but rather will compress and write directly to the supplied bitstream\&. Use this rather than \fBWrite()\fP and \fBCompress()\fP when you don't need the lossy or compressed value returned\&. 
.PP
Definition at line \fB831\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "virtual void Photon\&.Compression\&.TransformCrusher\&.ConstructDefault (bool isStatic = \fCfalse\fP)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line \fB168\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.CopyFrom (\fBTransformCrusher\fP source)"

.PP
Definition at line \fB1255\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Decompress (byte[] buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB912\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Decompress (\fBCompressedMatrix\fP compMatrix)"

.PP
Definition at line \fB940\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Decompress (\fBMatrix\fP nonalloc, \fBCompressedMatrix\fP compMatrix)"

.PP
Definition at line \fB927\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Decompress (\fBMatrix\fP nonalloc, uint[] buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB883\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Decompress (\fBMatrix\fP nonalloc, ulong compressed, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB890\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Decompress (\fBMatrix\fP nonalloc, ulong[] buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB876\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Decompress (uint[] buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB904\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Decompress (ulong compressed, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB920\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Decompress (ulong[] buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB896\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "override bool Photon\&.Compression\&.TransformCrusher\&.Equals (object obj)"

.PP
Definition at line \fB1264\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "bool Photon\&.Compression\&.TransformCrusher\&.Equals (\fBTransformCrusher\fP other)"

.PP
Definition at line \fB1269\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "override int Photon\&.Compression\&.TransformCrusher\&.GetHashCode ()"

.PP
Definition at line \fB1278\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Move (Rigidbody rb, byte[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB1084\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Move (Rigidbody rb, \fBCompressedMatrix\fP cmatrix)"

.PP
Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB1039\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Move (Rigidbody rb, \fBMatrix\fP matrix)"

.PP
Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB1053\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Move (Rigidbody rb, ulong frag0, ulong frag1 = \fC0\fP, ulong frag2 = \fC0\fP, ulong frag3 = \fC0\fP, ulong frag4 = \fC0\fP)"

.PP
Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB1066\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Move (Rigidbody rb, ulong[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Move Rigidbody to values of \fBCompressedMatrix\fP using rb\&.MovePosition and rb\&.MoveRotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB1075\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "override void Photon\&.Compression\&.TransformCrusher\&.OnAfterDeserialize ()"

.PP
Definition at line \fB193\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "override void Photon\&.Compression\&.TransformCrusher\&.OnBeforeSerialize ()"

.PP
Definition at line \fB191\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.OnCrusherChange (\fBElementCrusher\fP crusher)"

.PP
Callback fired whenever a component \fBElementCrusher\fP is changed\&. 
.PP
\fBParameters\fP
.RS 4
\fIcrusher\fP 
.RE
.PP

.PP
Definition at line \fB147\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.TransformCrusher\&.operator!= (\fBTransformCrusher\fP crusher1, \fBTransformCrusher\fP crusher2)\fC [static]\fP"

.PP
Definition at line \fB1294\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "static bool Photon\&.Compression\&.TransformCrusher\&.operator== (\fBTransformCrusher\fP crusher1, \fBTransformCrusher\fP crusher2)\fC [static]\fP"

.PP
Definition at line \fB1289\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (byte[] array, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB411\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (byte[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB393\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Read (\fBCompressedMatrix\fP nonalloc, byte[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB366\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Read (\fBCompressedMatrix\fP nonalloc, uint[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB434\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Read (\fBCompressedMatrix\fP nonalloc, ulong buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Extract a \fBCompressedMatrix\fP from a primitive buffer\&. Results will overwrite the supplied \fBCompressedMatrix\fP non-alloc\&. 
.PP
\fBParameters\fP
.RS 4
\fInonalloc\fP Target of the Read\&.
.br
\fIbuffer\fP Serialized source\&.
.br
\fIbcl\fP 
.RE
.PP

.PP
Definition at line \fB627\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Read (\fBCompressedMatrix\fP nonalloc, ulong buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Extract a \fBCompressedMatrix\fP from a primitive buffer\&. Results will overwrite the supplied \fBCompressedMatrix\fP non-alloc\&. 
.PP
\fBParameters\fP
.RS 4
\fInonalloc\fP Target of the Read\&.
.br
\fIbuffer\fP Serialized source\&.
.br
\fIbitposition\fP The read start position of the buffer\&. This value will be incremented by the number of bits read\&.
.br
\fIbcl\fP 
.RE
.PP

.PP
Definition at line \fB647\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Read (\fBCompressedMatrix\fP nonalloc, ulong frag0, ulong frag1 = \fC0\fP, ulong frag2 = \fC0\fP, ulong frag3 = \fC0\fP, ulong frag4 = \fC0\fP, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Reconstruct a \fBCompressedMatrix\fP from fragments\&. 
.PP
Definition at line \fB588\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Read (\fBCompressedMatrix\fP nonalloc, ulong[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB419\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (uint[] array, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB405\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (uint[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB388\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (ulong buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB662\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (ulong frag0, ulong frag1 = \fC0\fP, ulong frag2 = \fC0\fP, ulong frag3 = \fC0\fP, uint frag4 = \fC0\fP, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB611\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (ulong[] array, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB399\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBCompressedMatrix\fP Photon\&.Compression\&.TransformCrusher\&.Read (ulong[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB383\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.ReadAndApply (Transform target, byte[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Read the compressed value from a buffer, decompress it, and apply it to the target transform\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP 
.br
\fIbitstream\fP 
.br
\fIbcl\fP 
.RE
.PP

.PP
Definition at line \fB572\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (byte[] array, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB324\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (byte[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB359\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (\fBMatrix\fP nonalloc, byte[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB341\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (\fBMatrix\fP nonalloc, uint[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB336\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (\fBMatrix\fP nonalloc, ulong buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB538\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (\fBMatrix\fP nonalloc, ulong buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB550\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (\fBMatrix\fP nonalloc, ulong frag0, ulong frag1 = \fC0\fP, ulong frag2 = \fC0\fP, ulong frag3 = \fC0\fP, ulong frag4 = \fC0\fP, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB605\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (\fBMatrix\fP nonalloc, ulong[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB331\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (uint[] array, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB318\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (uint[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB353\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (ulong buffer, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB544\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (ulong buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB556\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (ulong[] array, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB312\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBMatrix\fP Photon\&.Compression\&.TransformCrusher\&.ReadAndDecompress (ulong[] array, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB347\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Set (Rigidbody rb, byte[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB1006\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Set (Rigidbody rb, \fBCompressedMatrix\fP cmatrix)"

.PP
Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB962\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Set (Rigidbody rb, \fBMatrix\fP matrix)"

.PP
Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB975\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Set (Rigidbody rb, ulong frag0, ulong frag1 = \fC0\fP, ulong frag2 = \fC0\fP, ulong frag3 = \fC0\fP, ulong frag4 = \fC0\fP)"

.PP
Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB988\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Set (Rigidbody rb, ulong[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB997\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Set (Rigidbody2D rb2d, \fBCompressedMatrix\fP cmatrix)"

.PP
Set Rigidbody to values of \fBCompressedMatrix\fP using rb\&.position and rb\&.rotation\&. Any axes not included in the Crusher are left as is\&. Scale uses rb\&.transform (rb doesn't handle scaling)\&.
.PP
Definition at line \fB1025\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Set (Rigidbody2D rb2d, \fBMatrix\fP matrix)"

.PP
Definition at line \fB1012\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "int Photon\&.Compression\&.TransformCrusher\&.TallyBits (BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Get the total number of bits this Transform is set to write\&. 
.PP
Definition at line \fB1247\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (\fBCompressedMatrix\fP cm, byte[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB242\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (\fBCompressedMatrix\fP cm, ref ulong buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Serialize a \fBCompressedMatrix\fP to a bitstream\&. 
.PP
\fBParameters\fP
.RS 4
\fIcm\fP Results of a previously compressed Transform \fBMatrix\fP\&.
.br
\fIbuffer\fP The write target\&.
.br
\fIbcl\fP 
.RE
.PP

.PP
Definition at line \fB502\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (\fBCompressedMatrix\fP cm, uint[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB255\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (\fBCompressedMatrix\fP cm, ulong[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB268\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (\fBCompressedMatrix\fP nonalloc, Transform transform, byte[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB281\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (\fBCompressedMatrix\fP nonalloc, Transform transform, ref ulong bitstream, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Compress a transform using this crusher, store the compressed results in a supplied \fBCompressedMatrix\fP, and serialize the compressed values to the bitstream\&. 
.PP
\fBParameters\fP
.RS 4
\fInonalloc\fP Populate this \fBCompressedMatrix\fP with the results of the cmopression operation\&.
.br
\fItransform\fP The transform to compress\&.
.br
\fIbitstream\fP The write target\&.
.br
\fIbcl\fP 
.RE
.PP

.PP
Definition at line \fB519\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (\fBCompressedMatrix\fP nonalloc, Transform transform, ref ulong buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Compress a transform using this crusher, store the compressed results in a supplied \fBCompressedMatrix\fP, and serialize the compressed values to the buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fInonalloc\fP Populate this \fBCompressedMatrix\fP with the results of the cmopression operation\&.
.br
\fItransform\fP The transform to compress\&.
.br
\fIbuffer\fP The write target\&.
.br
\fIbitposition\fP The write position for the buffer\&.
.br
\fIbcl\fP 
.RE
.PP

.PP
Definition at line \fB461\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (Transform transform, byte[] buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Definition at line \fB294\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "void Photon\&.Compression\&.TransformCrusher\&.Write (Transform transform, ref ulong buffer, ref int bitposition, BitCullingLevel bcl = \fCBitCullingLevel\&.NoCulling\fP)"

.PP
Compress and write all of the components of transform, without creating any intermediary \fBCompressedMatrix\fP or Bitstream\&. This is the most efficient way to compress and write a transform, but it will not return any compresed values for you to store or compare\&. 
.PP
\fBParameters\fP
.RS 4
\fItransform\fP The transform to compress\&.
.br
\fIbuffer\fP The write target\&.
.br
\fIbitposition\fP The write position for the buffer\&.
.br
\fIbcl\fP 
.RE
.PP

.PP
Definition at line \fB483\fP of file \fBTransformCrusher\&.cs\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "readonly int [] Photon\&.Compression\&.TransformCrusher\&._cached_total = new int[4]\fC [protected]\fP"

.PP
Definition at line \fB218\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "const int Photon\&.Compression\&.TransformCrusher\&.Build = 3503\fC [static]\fP"

.PP
Definition at line \fB28\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "bool Photon\&.Compression\&.TransformCrusher\&.cached\fC [protected]\fP"

.PP
Definition at line \fB221\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "readonly int [] Photon\&.Compression\&.TransformCrusher\&.cached_pBits = new int[4]\fC [protected]\fP"

.PP
Temporary \fBCompressedMatrix\fP used internally when a non-alloc is not provided and no return CM or M is required\&. 
.PP
Definition at line \fB215\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "readonly int [] Photon\&.Compression\&.TransformCrusher\&.cached_rBits = new int[4]\fC [protected]\fP"

.PP
Definition at line \fB216\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "readonly int [] Photon\&.Compression\&.TransformCrusher\&.cached_sBits = new int[4]\fC [protected]\fP"

.PP
Definition at line \fB217\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "ReadOnlyCollection<int> Photon\&.Compression\&.TransformCrusher\&.cached_total"

.PP
Definition at line \fB219\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "Transform Photon\&.Compression\&.TransformCrusher\&.defaultTransform"

.PP
Definition at line \fB68\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBElementCrusher\fP Photon\&.Compression\&.TransformCrusher\&.posCrusher\fC [protected]\fP"

.PP
Definition at line \fB71\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "ulong [] Photon\&.Compression\&.TransformCrusher\&.reusableArray64 = new ulong[5]\fC [static]\fP"

.PP
Definition at line \fB582\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBElementCrusher\fP Photon\&.Compression\&.TransformCrusher\&.rotCrusher\fC [protected]\fP"

.PP
Definition at line \fB72\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBElementCrusher\fP Photon\&.Compression\&.TransformCrusher\&.sclCrusher\fC [protected]\fP"

.PP
Definition at line \fB73\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "Dictionary<int, \fBTransformCrusher\fP> Photon\&.Compression\&.TransformCrusher\&.staticTransformCrushers = new Dictionary<int, \fBTransformCrusher\fP>()\fC [static]\fP"

.PP
Definition at line \fB32\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "const int Photon\&.Compression\&.TransformCrusher\&.VersionMajor = 3\fC [static]\fP"

.PP
Definition at line \fB25\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "const int Photon\&.Compression\&.TransformCrusher\&.VersionMinor = 5\fC [static]\fP"

.PP
Definition at line \fB26\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "const int Photon\&.Compression\&.TransformCrusher\&.VersionRevision = 3\fC [static]\fP"

.PP
Definition at line \fB27\fP of file \fBTransformCrusher\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "\fBElementCrusher\fP Photon\&.Compression\&.TransformCrusher\&.PosCrusher\fC [get]\fP, \fC [set]\fP"

.PP
Sets the position crusher to the assigned reference, and reruns \fBCacheValues()\fP\&. 
.PP
Definition at line \fB79\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBElementCrusher\fP Photon\&.Compression\&.TransformCrusher\&.RotCrusher\fC [get]\fP, \fC [set]\fP"

.PP
Sets the scale crusher to the assigned reference, and reruns \fBCacheValues()\fP\&. 
.PP
Definition at line \fB101\fP of file \fBTransformCrusher\&.cs\fP\&.
.SS "\fBElementCrusher\fP Photon\&.Compression\&.TransformCrusher\&.SclCrusher\fC [get]\fP, \fC [set]\fP"

.PP
Sets the scale crusher to the assigned reference, and reruns \fBCacheValues()\fP\&. 
.PP
Definition at line \fB123\fP of file \fBTransformCrusher\&.cs\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Purrpatrator User manual from the source code\&.
