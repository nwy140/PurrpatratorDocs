.TH "Photon.Pun.Simple.SyncVitals" 3 "Mon Apr 18 2022" "Purrpatrator User manual" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Photon.Pun.Simple.SyncVitals
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBPhoton\&.Pun\&.Simple\&.SyncObject< SyncVitals\&.Frame >\fP, \fBPhoton\&.Pun\&.Simple\&.IVitalsSystem\fP, \fBPhoton\&.Pun\&.Simple\&.IOnSnapshot\fP, \fBPhoton\&.Pun\&.Simple\&.IOnNetSerialize\fP, \fBPhoton\&.Pun\&.Simple\&.IOnAuthorityChanged\fP, \fBPhoton\&.Pun\&.Simple\&.IOnPostSimulate\fP, \fBPhoton\&.Pun\&.Simple\&.IOnVitalValueChange\fP, \fBPhoton\&.Pun\&.Simple\&.IOnCaptureState\fP, \fBPhoton\&.Pun\&.Simple\&.IUseKeyframes\fP, and \fBPhoton\&.Pun\&.Simple\&.IOnStateChange\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBFrame\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "override void \fBOnAwake\fP ()"
.br
.RI "Be sure to use base\&.OnAwake() when overriding\&. "
.ti -1c
.RI "override void \fBOnStart\fP ()"
.br
.ti -1c
.RI "override void \fBOnAuthorityChanged\fP (bool isMine, bool controllerChanged)"
.br
.ti -1c
.RI "\fBConsumption\fP \fBTryTrigger\fP (\fBIContactReactor\fP icontactReactor, \fBContactEvent\fP contactEvent, int compatibleMounts)"
.br
.ti -1c
.RI "\fBMount\fP \fBTryPickup\fP (\fBIContactReactor\fP reactor, \fBContactEvent\fP contactEvent)"
.br
.ti -1c
.RI "void \fBOnPostSimulate\fP (int frameId, int subFrameId, bool isNetTick)"
.br
.ti -1c
.RI "virtual void \fBOnCaptureCurrentState\fP (int frameId)"
.br
.ti -1c
.RI "\fBSerializationFlags\fP \fBOnNetSerialize\fP (int frameId, byte[] buffer, ref int bitposition, \fBSerializationFlags\fP writeFlags)"
.br
.ti -1c
.RI "\fBSerializationFlags\fP \fBOnNetDeserialize\fP (int originFrameId, byte[] buffer, ref int bitposition, \fBFrameArrival\fP arrival)"
.br
.ti -1c
.RI "double \fBApplyDamage\fP (double damage)"
.br
.RI "Returns how much of the damage was consumed\&. "
.ti -1c
.RI "void \fBOnVitalValueChange\fP (\fBVital\fP vital)"
.br
.ti -1c
.RI "void \fBOnVitalParamChange\fP (\fBVital\fP vital)"
.br
.ti -1c
.RI "void \fBOnStateChange\fP (\fBObjState\fP newState, \fBObjState\fP previousState, Transform attachmentTransform, \fBMount\fP attachTo=null, bool isReady=true)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBVitals\fP \fBvitals\fP = new \fBVitals\fP()"
.br
.ti -1c
.RI "\fBMountSelector\fP \fBdefaultMounting\fP = new \fBMountSelector\fP(0)"
.br
.ti -1c
.RI "bool \fBautoDespawn\fP = true"
.br
.ti -1c
.RI "bool \fBresetOnSpawn\fP = true"
.br
.ti -1c
.RI "List< \fBIOnVitalsValueChange\fP > \fBOnVitalsValueChange\fP = new List<\fBIOnVitalsValueChange\fP>(0)"
.br
.ti -1c
.RI "List< \fBIOnVitalsParamChange\fP > \fBOnVitalsParamChange\fP = new List<\fBIOnVitalsParamChange\fP>(0)"
.br
.ti -1c
.RI "List< \fBIOnRootVitalBecameZero\fP > \fBOnRootVitalBecameZero\fP = new List<\fBIOnRootVitalBecameZero\fP>(0)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "override void \fBPopulateFrames\fP ()"
.br
.RI "Override this with frame initialization code\&. "
.ti -1c
.RI "\fBConsumption\fP \fBTestConsumption\fP (double amountConsumed, \fBIVitalsConsumable\fP iva, \fBContactEvent\fP contactEvent)"
.br
.ti -1c
.RI "virtual void \fBRootVitalBecameZero\fP (\fBVital\fP vital)"
.br
.ti -1c
.RI "override void \fBApplySnapshot\fP (\fBFrame\fP snapframe, \fBFrame\fP targframe, bool snapIsValid, bool targIsValid)"
.br
.ti -1c
.RI "override void \fBInterpolateFrame\fP (\fBFrame\fP targframe, \fBFrame\fP startframe, \fBFrame\fP endframe, float t)"
.br
.ti -1c
.RI "override void \fBExtrapolateFrame\fP (\fBFrame\fP prevframe, \fBFrame\fP snapframe, \fBFrame\fP targframe)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBContactGroupMaskSelector\fP \fBcontactGroups\fP = new \fBContactGroupMaskSelector\fP()"
.br
.ti -1c
.RI "\fBSyncState\fP \fBsyncState\fP"
.br
.ti -1c
.RI "\fBVital\fP \fBrootVital\fP"
.br
.ti -1c
.RI "int \fBdefaultMountingMask\fP"
.br
.ti -1c
.RI "bool \fBisPredicted\fP"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "override int \fBApplyOrder\fP\fC [get]\fP"
.br
.ti -1c
.RI "override bool \fBAllowReconstructionOfEmpty\fP\fC [get]\fP"
.br
.ti -1c
.RI "byte \fBSystemIndex\fP\fC [getset]\fP"
.br
.ti -1c
.RI "\fBVitals\fP \fBVitals\fP\fC [get]\fP"
.br
.ti -1c
.RI "\fBIContactGroupMask\fP \fBValidContactGroups\fP\fC [get]\fP"
.br
.ti -1c
.RI "int \fBValidMountsMask\fP\fC [get]\fP"
.br
.ti -1c
.RI "\fBMount\fP \fBDefaultMount\fP\fC [getset]\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB20\fP of file \fBSyncVitals\&.cs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "double Photon\&.Pun\&.Simple\&.SyncVitals\&.ApplyDamage (double damage)"

.PP
Returns how much of the damage was consumed\&. 
.PP
\fBParameters\fP
.RS 4
\fIdamage\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB331\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override void Photon\&.Pun\&.Simple\&.SyncVitals\&.ApplySnapshot (\fBFrame\fP snapframe, \fBFrame\fP targframe, bool snapIsValid, bool targIsValid)\fC [protected]\fP"

.PP
Definition at line \fB399\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override void Photon\&.Pun\&.Simple\&.SyncVitals\&.ExtrapolateFrame (\fBFrame\fP prevframe, \fBFrame\fP snapframe, \fBFrame\fP targframe)\fC [protected]\fP"
TODO: Maybe should be \&.Complete?
.PP
Definition at line \fB415\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override void Photon\&.Pun\&.Simple\&.SyncVitals\&.InterpolateFrame (\fBFrame\fP targframe, \fBFrame\fP startframe, \fBFrame\fP endframe, float t)\fC [protected]\fP"
TODO: This isn't really an interpolate\&. Might want to try to make one\&.
.PP
Definition at line \fB409\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnAuthorityChanged (bool isMine, bool controllerChanged)"

.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IOnAuthorityChanged\fP\&.
.PP
Definition at line \fB161\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnAwake ()\fC [virtual]\fP"

.PP
Be sure to use base\&.OnAwake() when overriding\&. This is called when the \fBNetObject\fP runs \fBAwake()\fP\&. All code that depends on the NetObj being initialized should use this rather than \fBAwake()\fP; subscribe to callbacks to \fBVitals\fP changes
.PP
Reimplemented from \fBPhoton\&.Pun\&.Simple\&.NetComponent\fP\&.
.PP
Definition at line \fB115\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "virtual void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnCaptureCurrentState (int frameId)\fC [virtual]\fP"

.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IOnCaptureState\fP\&.
.PP
Definition at line \fB266\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBSerializationFlags\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.OnNetDeserialize (int originFrameId, byte[] buffer, ref int bitposition, \fBFrameArrival\fP arrival)"
Needs to ignore any incoming updates that are the server/relay mirroring back what we sent
.PP
If frame is empty, we are done here\&. Typically means object was disabled\&.
.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IOnNetSerialize\fP\&.
.PP
Definition at line \fB296\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBSerializationFlags\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.OnNetSerialize (int frameId, byte[] buffer, ref int bitposition, \fBSerializationFlags\fP writeFlags)"
Don't transmit data if this component is disabled\&. Allows for muting components Simply by disabling them at the authority side\&.
.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IOnNetSerialize\fP\&.
.PP
Definition at line \fB275\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnPostSimulate (int frameId, int subFrameId, bool isNetTick)"

.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IOnPostSimulate\fP\&.
.PP
Definition at line \fB260\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnStart ()\fC [virtual]\fP"
Invalid default mounting (doesn't exist)\&.\&.\&. warn and set to Root
.PP
Reimplemented from \fBPhoton\&.Pun\&.Simple\&.NetComponent\fP\&.
.PP
Definition at line \fB138\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnStateChange (\fBObjState\fP newState, \fBObjState\fP previousState, Transform attachmentTransform, \fBMount\fP attachTo = \fCnull\fP, bool isReady = \fCtrue\fP)"
Detect respawn (change from despawned to any other state currently) and reset values when that occurs\&.
.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IOnStateChange\fP\&.
.PP
Definition at line \fB374\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnVitalParamChange (\fBVital\fP vital)"

.PP
Definition at line \fB353\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "void Photon\&.Pun\&.Simple\&.SyncVitals\&.OnVitalValueChange (\fBVital\fP vital)"

.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IOnVitalValueChange\fP\&.
.PP
Definition at line \fB342\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override void Photon\&.Pun\&.Simple\&.SyncVitals\&.PopulateFrames ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Override this with frame initialization code\&. The default base just creates the frame instances and assigns them index values\&. Basic factory, just gives each frame an index\&.
.PP
Reimplemented from \fBPhoton\&.Pun\&.Simple\&.SyncObject< SyncVitals\&.Frame >\fP\&.
.PP
Definition at line \fB104\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "virtual void Photon\&.Pun\&.Simple\&.SyncVitals\&.RootVitalBecameZero (\fBVital\fP vital)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line \fB361\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBConsumption\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.TestConsumption (double amountConsumed, \fBIVitalsConsumable\fP iva, \fBContactEvent\fP contactEvent)\fC [protected]\fP"

.PP
Definition at line \fB231\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBMount\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.TryPickup (\fBIContactReactor\fP reactor, \fBContactEvent\fP contactEvent)"

.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IContactSystem\fP\&.
.PP
Definition at line \fB255\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBConsumption\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.TryTrigger (\fBIContactReactor\fP icontactReactor, \fBContactEvent\fP contactEvent, int compatibleMounts)"
First test to see if the contacting and contacted are a groups match - if not return false\&.
.PP
If both are set to 0 (Root) then consider that a match, otherwise zero for one but not the other is a mismatch (for now)
.PP
Apply changes resulting from the trigger\&. Return true if affected/consumed\&. This bool is used to inform whether the trigger should despawn/pickup\&.
.PP
Apply to vital if vital has authority\&.
.PP
\fBVital\fP does not belong to us, but we want to know IF it would have been consumed for prediction purposes\&.
.PP
Implements \fBPhoton\&.Pun\&.Simple\&.IContactSystem\fP\&.
.PP
Definition at line \fB169\fP of file \fBSyncVitals\&.cs\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "bool Photon\&.Pun\&.Simple\&.SyncVitals\&.autoDespawn = true"

.PP
Definition at line \fB56\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBContactGroupMaskSelector\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.contactGroups = new \fBContactGroupMaskSelector\fP()\fC [protected]\fP"

.PP
Definition at line \fB46\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBMountSelector\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.defaultMounting = new \fBMountSelector\fP(0)"

.PP
Definition at line \fB50\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "int Photon\&.Pun\&.Simple\&.SyncVitals\&.defaultMountingMask\fC [protected]\fP"

.PP
Definition at line \fB75\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "bool Photon\&.Pun\&.Simple\&.SyncVitals\&.isPredicted\fC [protected]\fP"

.PP
Definition at line \fB78\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "List<\fBIOnRootVitalBecameZero\fP> Photon\&.Pun\&.Simple\&.SyncVitals\&.OnRootVitalBecameZero = new List<\fBIOnRootVitalBecameZero\fP>(0)"

.PP
Definition at line \fB68\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "List<\fBIOnVitalsParamChange\fP> Photon\&.Pun\&.Simple\&.SyncVitals\&.OnVitalsParamChange = new List<\fBIOnVitalsParamChange\fP>(0)"

.PP
Definition at line \fB67\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "List<\fBIOnVitalsValueChange\fP> Photon\&.Pun\&.Simple\&.SyncVitals\&.OnVitalsValueChange = new List<\fBIOnVitalsValueChange\fP>(0)"

.PP
Definition at line \fB66\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "bool Photon\&.Pun\&.Simple\&.SyncVitals\&.resetOnSpawn = true"

.PP
Definition at line \fB58\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBVital\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.rootVital\fC [protected]\fP"

.PP
Definition at line \fB73\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBSyncState\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.syncState\fC [protected]\fP"

.PP
Definition at line \fB71\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBVitals\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.vitals = new \fBVitals\fP()"

.PP
Definition at line \fB42\fP of file \fBSyncVitals\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "override bool Photon\&.Pun\&.Simple\&.SyncVitals\&.AllowReconstructionOfEmpty\fC [get]\fP"

.PP
Definition at line \fB36\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "override int Photon\&.Pun\&.Simple\&.SyncVitals\&.ApplyOrder\fC [get]\fP"

.PP
Definition at line \fB32\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBMount\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.DefaultMount\fC [get]\fP, \fC [set]\fP"

.PP
Definition at line \fB53\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "byte Photon\&.Pun\&.Simple\&.SyncVitals\&.SystemIndex\fC [get]\fP, \fC [set]\fP"

.PP
Definition at line \fB38\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBIContactGroupMask\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.ValidContactGroups\fC [get]\fP"

.PP
Definition at line \fB47\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "int Photon\&.Pun\&.Simple\&.SyncVitals\&.ValidMountsMask\fC [get]\fP"

.PP
Definition at line \fB51\fP of file \fBSyncVitals\&.cs\fP\&.
.SS "\fBVitals\fP Photon\&.Pun\&.Simple\&.SyncVitals\&.Vitals\fC [get]\fP"

.PP
Definition at line \fB43\fP of file \fBSyncVitals\&.cs\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Purrpatrator User manual from the source code\&.
